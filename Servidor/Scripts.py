import socket
import threading
import socket
import secrets
import struct
import random
import datetime
import time
import json
import os
import os.path
from os import path
from random import seed
from random import randint
from Crypto.Cipher import AES

def Gerar_Endereco_De_IP():

    ip = "127.0.0.1"

    arquivo_ip = "IP.txt";
    if os.path.isfile(arquivo_ip) and os.access(arquivo_ip, os.R_OK):

        with open(arquivo_ip) as ip_data_text:
            ip = ip_data_text
    
    else:
    
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    

    with open("c:\GBTH\IP.txt", "w") as f:
        f.write(ip)
    
    return ip


def Gerar_Tipo_De_IP():

    tipo = "LOCAL";

    arquivo_ip = "IP.txt";
    if os.path.isfile(arquivo_ip) and os.access(arquivo_ip, os.R_OK):

        with open(arquivo_ip) as ip_data_text:
            tipo = "FIXO";
    
    else:
    
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        tipo = "LOCAL";
    
    return tipo


def Carregar_Lista_De_Servidores():

    arquivo_servidores = "Temporarios\Servidores.txt";
    json_servidores = "{\n\"servidores\": [\n{\"titulo\": \"Servidor [IP]\",\"descricao\": \"\\nServidor Aberto\",\"porta\": 8370,\"capacidade_atual\": 5,\"capacidade_total\": 100,\"ativado\": true},\n{\"titulo\": \"Quem Criou o Servidor?\",\"descricao\": \"Thalles Tutoriais\\nCanal do Youtube\",\"porta\": 8370,\"capacidade_atual\": 100,\"capacidade_total\": 100,\"ativado\": false},\n{\"titulo\": \"Como Funciona?\",\"descricao\": \"Jogue Sozinho\\nOu Em Rede Local\",\"porta\": 8370,\"capacidade_atual\": 100,\"capacidade_total\": 100,\"ativado\": false},\n{\"titulo\": \"Qual o IP do Servidor?\",\"descricao\": \"IP: [IP]\\nIP de Rede: [IP]\",\"porta\": 8370,\"capacidade_atual\": 100,\"capacidade_total\": 100,\"ativado\": false},\n{\"titulo\": \"Comandos do Gunbound\",\"descricao\": \"Digite /help\\nPara Ver os Comandos\",\"porta\": 8370,\"capacidade_atual\": 100,\"capacidade_total\": 100,\"ativado\": false},\n{\"titulo\": \"Precisa de Ajuda?\",\"descricao\": \"Veja o Tutorial em:\\nhttps://thalles.net/gb\",\"porta\": 8370,\"capacidade_atual\": 100,\"capacidade_total\": 100,\"ativado\": false}\n]\n}\n"
    if os.path.isfile(arquivo_servidores) and os.access(arquivo_servidores, os.R_OK):

        with open(arquivo_servidores) as directory_data_text:
            data_servidores = json.load(directory_data_text)
        
    else:
    
        data_servidores = json.loads(json_servidores)

        with open(arquivo_servidores, "w") as f:
            f.write(json_servidores)



    server_options = []
    for json_row in data_servidores["servidores"]:
        server_options.append(ServerOption(json_row["titulo"].replace("[IP]", Gerar_Endereco_De_IP()), json_row["descricao"].replace("[IP]", Gerar_Endereco_De_IP()), Gerar_Endereco_De_IP(), json_row["porta"], json_row["capacidade_atual"], json_row["capacidade_total"], json_row["ativado"]))


    return server_options


def Gerar_Avatar_Random(genero):
    chapelMASCULINO = ["01800100", "02800100", "03800100", "04800100", "05800100", "06800100", "07800100", "08800100", "09800100", "0A800100", "0B800100", "0D800100", "0E800100", "0F800100", "10800100", "11800100", "12800100", "13800100", "14800100", "15800100", "16800100", "17800100", "18800100", "19800100", "1A800100", "1B800100", "1C800100", "1D800100", "1E800100", "1F800100", "20800100", "21800100", "22800100", "23800100", "24800100", "25800100", "26800100", "27800100", "28800100", "29800100", "2A800100", "2B800100", "2C800100", "2D800100", "2E800100", "2F800100", "30800100", "31800100", "32800100", "33800100", "34800100", "35800100", "36800100", "37800100", "38800100", "39800100", "3A800100", "3B800100", "3C800100", "3D800100", "3E800100", "3F800100", "40800100", "41800100", "42800100", "43800100", "44800100", "45800100", "46800100", "47800100", "48800100", "49800100", "4A800100", "4B800100", "4C800100", "4D800100", "4E800100", "4F800100", "50800100", "51800100", "52800100", "53800100", "54800100", "55800100", "56800100", "57800100", "58800100", "59800100", "5A800100", "5B800100", "5C800100", "5D800100", "5E800100", "5F800100", "60800100", "61800100", "62800100", "63800100", "64800100", "65800100", "68800100", "69800100", "6A800100", "6B800100", "6D800100", "6E800100", "6F800100", "70800100", "71800100", "72800100", "73800100", "74800100", "75800100", "76800100", "77800100", "78800100", "7A800100", "7B800100", "7C800100", "7D800100", "7E800100", "7F800100", "80800100", "81800100", "82800100", "83800100", "84800100", "85800100", "86800100", "87800100", "88800100", "89800100", "8A800100", "8B800100", "8C800100", "8E800100", "8F800100", "90800100", "91800100", "92800100", "95800100", "96800100", "97800100", "98800100", "99800100", "9A800100", "9B800100", "9C800100", "9D800100", "9E800100", "9F800100", "A0800100", "A1800100", "A2800100", "A3800100", "A4800100", "A5800100", "A6800100", "A7800100", "A8800100", "A9800100", "AA800100", "AB800100", "AC800100", "AD800100", "AE800100", "B0800100", "B1800100", "B2800100", "B3800100", "B4800100", "B5800100", "B6800100", "B7800100", "B8800100", "B9800100", "C3800100", "C5800100", "C6800100", "C7800100", "CC800100", "CD800100", "D2800100", "D3800100", "D8800100", "D9800100", "DA800100", "DB800100", "DC800100", "DE800100", "E8800100", "E9800100", "EC800100", "ED800100", "EE800100", "EF800100", "F0800100", "F6800100", "F7800100", "F8800100", "FB800100", "FC800100", "FD800100", "00810100", "03810100", "04810100", "05810100", "06810100", "07810100", "08810100", "09810100", "0A810100", "0B810100", "0D810100", "0F810100", "10810100", "11810100", "12810100", "13810100", "14810100", "15810100", "16810100", "17810100", "18810100", "19810100", "1A810100", "1B810100", "1C810100", "1E810100", "1F810100", "22810100", "23810100", "24810100", "25810100", "26810100", "27810100", "28810100", "29810100", "2A810100", "2B810100", "2C810100", "2D810100", "2E810100", "2F810100", "30810100", "34810100", "35810100", "36810100", "37810100", "38810100", "39810100", "3A810100", "3B810100", "3C810100", "3D810100", "3E810100", "3F810100", "40810100", "41810100", "42810100", "43810100", "44810100", "70810100", "71810100", "72810100", "73810100", "74810100", "75810100", "76810100", "77810100", "78810100", "79810100", "7A810100", "7B810100", "7C810100", "7D810100", "7E810100", "7F810100", "80810100", "81810100", "82810100", "83810100", "84810100", "85810100", "86810100", "87810100", "88810100", "89810100", "8A810100", "8A810100", "8B810100", "8C810100", "8D810100", "8E810100", "8F810100", "90810100", "91810100", "92810100", "93810100", "94810100", "95810100", "96810100", "97810100", "98810100", "99810100", "9A810100", "9B810100", "9C810100", "9D810100", "9E810100", "9F810100", "A0810100", "A1810100", "A2810100", "A3810100", "A4810100", "A5810100", "A6810100", "A7810100", "A8810100", "A9810100", "AA810100", "AB810100", "AC810100", "AD810100", "AE810100", "AF810100", "B0810100", "B1810100", "B2810100", "B3810100", "B4810100", "B5810100", "B6810100", "B7810100", "B8810100", "B9810100", "BA810100", "BB810100", "BC810100", "BD810100", "BE810100", "BF810100", "C0810100", "C1810100", "C2810100", "C3810100", "C4810100", "C5810100", "C6810100", "C7810100", "C8810100", "C9810100", "CA810100", "CB810100", "CC810100", "F2810100", "F3810100", "F4810100", "F5810100", "F6810100", "F7810100", "F8810100", "F9810100", "FA810100", "FB810100", "FC810100", "FD810100", "FE810100", "FF810100", "00820100", "01820100", "03820100", "04820100", "05820100", "06820100", "07820100", "08820100", "09820100", "0A820100", "0B820100", "0C820100", "0D820100", "0E820100", "0F820100", "10820100", "11820100", "12820100", "13820100", "14820100", "15820100", "16820100", "56820100", "57820100", "58820100", "59820100", "5A820100", "5B820100", "5C820100", "5D820100", "5E820100", "5F820100", "60820100", "61820100", "62820100", "63820100", "64820100", "65820100", "66820100", "67820100", "68820100", "69820100", "6A820100", "6B820100", "6D820100", "6E820100", "71820100", "7A820100", "7B820100", "7C820100", "7D820100", "7E820100", "7F820100", "80820100", "81820100", "82820100", "83820100", "84820100", "85820100", "86820100", "87820100", "88820100", "89820100", "8A820100", "8B820100", "8C820100", "8D820100", "8E820100", "8F820100", "90820100", "91820100", "92820100", "93820100", "94820100", "96820100", "98820100", "99820100", "9A820100", "9B820100", "9C820100", "9D820100", "9E820100", "9F820100", "A0820100", "A1820100", "A2820100", "A3820100", "A4820100", "A5820100", "A7820100", "A8820100", "A9820100", "AA820100", "AB820100", "AC820100", "AE820100", "AF820100", "B0820100", "B1820100", "B2820100", "B3820100", "B4820100", "B5820100", "B6820100", "B7820100", "B8820100", "B9820100", "CF820100"];
    roupaMASCULINO = ["01800000", "02800000", "03800000", "04800000", "05800000", "06800000", "07800000", "08800000", "09800000", "0A800000", "0B800000", "0C800000", "0D800000", "0E800000", "0F800000", "10800000", "11800000", "12800000", "13800000", "14800000", "15800000", "16800000", "17800000", "18800000", "19800000", "1A800000", "1B800000", "1C800000", "1D800000", "1E800000", "1F800000", "20800000", "21800000", "22800000", "23800000", "24800000", "25800000", "26800000", "27800000", "28800000", "29800000", "2A800000", "2B800000", "2C800000", "2D800000", "2E800000", "2F800000", "30800000", "31800000", "32800000", "33800000", "34800000", "35800000", "36800000", "37800000", "38800000", "39800000", "3A800000", "3B800000", "3C800000", "3D800000", "3E800000", "3F800000", "40800000", "41800000", "42800000", "43800000", "44800000", "45800000", "46800000", "47800000", "48800000", "49800000", "4A800000", "4B800000", "4C800000", "4D800000", "4E800000", "4F800000", "50800000", "51800000", "52800000", "53800000", "54800000", "55800000", "56800000", "57800000", "58800000", "59800000", "5A800000", "5B800000", "5C800000", "5D800000", "5E800000", "5F800000", "60800000", "61800000", "62800000", "63800000", "6D800000", "6E800000", "6F800000", "70800000", "71800000", "72800000", "73800000", "74800000", "75800000", "76800000", "77800000", "78800000", "79800000", "7A800000", "7B800000", "7C800000", "7D800000", "7E800000", "7F800000", "80800000", "81800000", "82800000", "83800000", "84800000", "85800000", "86800000", "87800000", "88800000", "89800000", "8A800000", "8B800000", "8C800000", "8E800000", "8F800000", "90800000", "91800000", "92800000", "94800000", "95800000", "96800000", "97800000", "98800000", "99800000", "9A800000", "9B800000", "9C800000", "9D800000", "9E800000", "9F800000", "A0800000", "A1800000", "A2800000", "A3800000", "A4800000", "A5800000", "A6800000", "A7800000", "A8800000", "A9800000", "AA800000", "B2800000", "B3800000", "B4800000", "B5800000", "B8800000", "B9800000", "C4800000", "C6800000", "C7800000", "CC800000", "CD800000", "D2800000", "D3800000", "D8800000", "D9800000", "DA800000", "DB800000", "DC800000", "DE800000", "E8800000", "E9800000", "EC800000", "ED800000", "EE800000", "EF800000", "F0800000", "F6800000", "F7800000", "F8800000", "FB800000", "FC800000", "FD800000", "00810000", "03810000", "04810000", "05810000", "06810000", "07810000", "08810000", "09810000", "0A810000", "0B810000", "0D810000", "0F810000", "10810000", "11810000", "12810000", "13810000", "14810000", "15810000", "16810000", "17810000", "18810000", "19810000", "1A810000", "1B810000", "1C810000", "1E810000", "1F810000", "22810000", "23810000", "24810000", "25810000", "26810000", "27810000", "28810000", "29810000", "2A810000", "2B810000", "2C810000", "2D810000", "2E810000", "2F810000", "30810000", "32810000", "33810000", "34810000", "35810000", "36810000", "37810000", "38810000", "39810000", "3A810000", "3B810000", "3C810000", "3D810000", "3E810000", "3F810000", "40810000", "41810000", "42810000", "43810000", "44810000", "70810000", "71810000", "72810000", "73810000", "74810000", "75810000", "76810000", "77810000", "78810000", "79810000", "7A810000", "7B810000", "7C810000", "7D810000", "7E810000", "7F810000", "80810000", "81810000", "82810000", "83810000", "84810000", "85810000", "86810000", "87810000", "88810000", "89810000", "8A810000", "8B810000", "8C810000", "8D810000", "8E810000", "8F810000", "90810000", "91810000", "92810000", "93810000", "94810000", "95810000", "96810000", "97810000", "98810000", "99810000", "9A810000", "9B810000", "9C810000", "9D810000", "9E810000", "9F810000", "A0810000", "A1810000", "A2810000", "A3810000", "A4810000", "A5810000", "A6810000", "A7810000", "A8810000", "A9810000", "AA810000", "AB810000", "AC810000", "AD810000", "AE810000", "AF810000", "B0810000", "B1810000", "B2810000", "B3810000", "B4810000", "B5810000", "B6810000", "B7810000", "B8810000", "B9810000", "BA810000", "BB810000", "BC810000", "BD810000", "BE810000", "BF810000", "C0810000", "C1810000", "C2810000", "C3810000", "C4810000", "C5810000", "C6810000", "C7810000", "C8810000", "C9810000", "CA810000", "CB810000", "CC810000", "F2810000", "F3810000", "F4810000", "F5810000", "F6810000", "F7810000", "F8810000", "F9810000", "FA810000", "FB810000", "FC810000", "FD810000", "FE810000", "FF810000", "00820000", "01820000", "03820000", "04820000", "05820000", "06820000", "07820000", "08820000", "09820000", "0A820000", "0B820000", "0C820000", "0D820000", "0E820000", "0F820000", "10820000", "11820000", "12820000", "13820000", "14820000", "15820000", "16820000", "56820000", "57820000", "58820000", "59820000", "5A820000", "5B820000", "5C820000", "5D820000", "5E820000", "5F820000", "60820000", "61820000", "62820000", "63820000", "64820000", "65820000", "66820000", "67820000", "68820000", "69820000", "6A820000", "6B820000", "6D820000", "6E820000", "71820000", "7A820000", "7B820000", "7C820000", "7D820000", "7E820000", "7F820000", "80820000", "81820000", "82820000", "83820000", "84820000", "85820000", "86820000", "87820000", "88820000", "89820000", "8A820000", "8B820000", "8C820000", "8D820000", "8E820000", "8F820000", "90820000", "91820000", "92820000", "93820000", "94820000", "96820000", "98820000", "99820000", "9A820000", "9B820000", "9C820000", "9D820000", "9E820000", "9F820000", "A0820000", "A1820000", "A2820000", "A3820000", "A4820000", "A5820000", "A7820000", "A8820000", "A9820000", "AA820000", "AB820000", "AC820000", "AE820000", "AF820000", "B0820000", "B1820000", "B2820000", "B3820000", "B4820000", "B5820000", "B6820000", "B7820000", "B8820000", "B9820000", "CF820000"];
    oculosMASCULINO = ["01800200", "02800200", "03800200", "04800200", "05800200", "06800200", "07800200", "08800200", "09800200", "0A800200", "0B800200", "0C800200", "0D800200", "0E800200", "0F800200", "10800200", "11800200", "12800200", "14800200", "15800200", "16800200", "17800200", "18800200", "19800200", "1A800200", "1B800200", "1C800200", "1D800200", "1E800200", "1F800200", "20800200", "21800200", "22800200", "23800200", "24800200", "25800200", "26800200", "27800200", "28800200", "2A800200", "2B800200", "2C800200", "2D800200", "2E800200", "2F800200", "30800200", "31800200", "32800200", "33800200", "34800200", "35800200", "36800200", "37800200", "38800200", "39800200", "3A800200", "3B800200", "3C800200", "3D800200", "3F800200", "41800200", "47800200", "48800200", "4D800200", "4E800200", "4F800200", "50800200", "56800200", "57800200", "58800200", "59800200", "5B800200", "5D800200", "5F800200", "60800200", "62800200", "66800200", "67800200", "69800200", "6A800200", "6B800200", "6F800200", "70800200", "72800200", "73800200", "76800200", "77800200", "78800200", "7B800200", "7C800200", "7D800200", "7E800200", "7F800200", "80800200", "81800200", "82800200", "83800200", "85800200", "86800200", "87800200", "88800200", "89800200", "8A800200", "8B800200", "8C800200", "8D800200", "8E800200", "8F800200", "90800200", "91800200", "92800200", "93800200", "94800200", "95800200", "96800200", "97800200", "98800200", "99800200", "9A800200", "9B800200", "9C800200", "9D800200", "9E800200", "9F800200", "A0800200", "A1800200", "A2800200", "A3800200", "A4800200", "A6800200", "A7800200", "A8800200", "A9800200", "AA800200", "AB800200", "AC800200", "AD800200", "AE800200", "AF800200", "B0800200", "B1800200", "B2800200", "B3800200", "B4800200", "B5800200", "B6800200", "B7800200", "B8800200", "B9800200", "BA800200", "18810200", "19810200", "1A810200", "1C810200", "1D810200", "1E810200", "1F810200", "20810200", "21810200", "23810200", "24810200", "26810200", "27810200", "28810200", "29810200", "2A810200", "2C810200", "2D810200"];
    chapelFEMININO = ["01000100", "02000100", "03000100", "04000100", "05000100", "06000100", "07000100", "08000100", "09000100", "0A000100", "0B000100", "0C000100", "0E000100", "0F000100", "10000100", "11000100", "12000100", "13000100", "14000100", "15000100", "16000100", "17000100", "18000100", "19000100", "1A000100", "1B000100", "1C000100", "1D000100", "1E000100", "1F000100", "20000100", "21000100", "22000100", "23000100", "24000100", "25000100", "26000100", "27000100", "28000100", "29000100", "2A000100", "2B000100", "2C000100", "2D000100", "2E000100", "2F000100", "30000100", "31000100", "32000100", "33000100", "34000100", "35000100", "36000100", "37000100", "38000100", "39000100", "3A000100", "3B000100", "3C000100", "3D000100", "3E000100", "3F000100", "40000100", "41000100", "42000100", "43000100", "44000100", "45000100", "46000100", "47000100", "48000100", "49000100", "4A000100", "4B000100", "4C000100", "4D000100", "4E000100", "4F000100", "50000100", "51000100", "52000100", "53000100", "54000100", "55000100", "56000100", "57000100", "58000100", "59000100", "5A000100", "5B000100", "5C000100", "5D000100", "5E000100", "60000100", "61000100", "62000100", "63000100", "64000100", "65000100", "66000100", "67000100", "68000100", "69000100", "6A000100", "6B000100", "6C000100", "6D000100", "6E000100", "6F000100", "71000100", "72000100", "73000100", "74000100", "75000100", "76000100", "77000100", "78000100", "7B000100", "7C000100", "7E000100", "7F000100", "80000100", "81000100", "82000100", "83000100", "84000100", "85000100", "86000100", "87000100", "88000100", "89000100", "8A000100", "8B000100", "8C000100", "8D000100", "8E000100", "8F000100", "90000100", "92000100", "93000100", "94000100", "95000100", "96000100", "99000100", "9A000100", "9B000100", "9C000100", "9D000100", "9E000100", "9F000100", "A0000100", "A1000100", "A2000100", "A3000100", "A4000100", "A5000100", "A6000100", "A7000100", "A8000100", "A9000100", "AA000100", "AC000100", "AD000100", "AE000100", "AF000100", "B0000100", "B1000100", "B2000100", "B3000100", "B4000100", "B5000100", "B6000100", "B7000100", "B8000100", "B9000100", "BA000100", "BB000100", "BC000100", "BD000100", "BE000100", "C4000100", "C6000100", "C7000100", "C8000100", "CD000100", "CE000100", "D3000100", "D4000100", "D9000100", "DA000100", "DB000100", "DC000100", "DD000100", "DF000100", "E9000100", "EA000100", "ED000100", "EE000100", "EF000100", "F0000100", "F1000100", "F6000100", "F7000100", "F8000100", "FB000100", "FC000100", "FD000100", "00010100", "03010100", "04010100", "05010100", "06010100", "07010100", "08010100", "09010100", "0A010100", "0B010100", "0C010100", "0E010100", "10010100", "11010100", "12010100", "13010100", "14010100", "15010100", "16010100", "17010100", "18010100", "19010100", "1A010100", "1B010100", "1C010100", "1E010100", "1F010100", "22010100", "23010100", "24010100", "25010100", "26010100", "27010100", "28010100", "29010100", "2A010100", "2B010100", "2C010100", "2D010100", "2E010100", "2F010100", "30010100", "32010100", "33010100", "34010100", "35010100", "36010100", "37010100", "38010100", "39010100", "3A010100", "3C010100", "3D010100", "3E010100", "3F010100", "40010100", "41010100", "42010100", "43010100", "44010100", "70010100", "71010100", "72010100", "73010100", "74010100", "75010100", "76010100", "77010100", "78010100", "79010100", "7A010100", "7B010100", "7C010100", "7D010100", "7E010100", "7F010100", "80010100", "81010100", "82010100", "83010100", "84010100", "85010100", "86010100", "87010100", "88010100", "89010100", "8A010100", "8B010100", "8C010100", "8D010100", "8E010100", "8F010100", "90010100", "91010100", "92010100", "93010100", "94010100", "95010100", "96010100", "97010100", "98010100", "99010100", "9A010100", "9B010100", "9C010100", "9D010100", "9E010100", "9F010100", "A0010100", "A1010100", "A2010100", "A3010100", "A4010100", "A5010100", "A6010100", "A7010100", "A8010100", "A9010100", "AA010100", "AB010100", "AC010100", "AD010100", "AE010100", "AF010100", "B0010100", "B1010100", "B2010100", "B3010100", "B4010100", "B5010100", "B6010100", "B7010100", "B8010100", "B9010100", "BA010100", "BB010100", "BC010100", "BD010100", "BE010100", "BF010100", "C0010100", "C1010100", "C2010100", "C3010100", "C4010100", "C5010100", "C6010100", "C7010100", "C8010100", "C9010100", "CA010100", "CB010100", "CC010100", "F2010100", "F3010100", "F4010100", "F5010100", "F6010100", "F7010100", "F8010100", "F9010100", "FA010100", "FB010100", "FC010100", "FD010100", "FE010100", "FF010100", "00020100", "01020100", "03020100", "04020100", "05020100", "06020100", "07020100", "08020100", "09020100", "0A020100", "0B020100", "0C020100", "0D020100", "0E020100", "0F020100", "10020100", "11020100", "12020100", "13020100", "14020100", "15020100", "16020100", "0E020100", "0F020100", "10020100", "11020100", "12020100", "13020100", "14020100", "15020100", "16020100", "56020100", "57020100", "58020100", "59020100", "5A020100", "5B020100", "5C020100", "5D020100", "5E020100", "5F020100", "60020100", "61020100", "62020100", "63020100", "64020100", "65020100", "66020100", "67020100", "68020100", "69020100", "6A020100", "6B020100", "6D020100", "6E020100", "71020100", "7A020100", "7B020100", "7C020100", "7D020100", "7E020100", "7F020100", "80020100", "81020100", "82020100", "83020100", "84020100", "85020100", "86020100", "87020100", "88020100", "89020100", "8A020100", "8B020100", "8C020100", "8D020100", "8E020100", "8F020100", "90020100", "91020100", "92020100", "93020100", "94020100", "96020100", "98020100", "99020100", "9A020100", "9B020100", "9C020100", "9D020100", "9E020100", "9F020100", "A0020100", "A1020100", "A2020100", "A3020100", "A4020100", "A5020100", "A7020100", "A8020100", "A9020100", "AA020100", "AB020100", "AC020100", "AE020100", "AF020100", "B0020100", "B1020100", "B2020100", "B3020100", "B4020100", "B5020100", "B6020100", "B7020100", "B8020100", "B9020100", "CF020100"];
    roupaFEMININO = ["01000000", "02000000", "03000000", "04000000", "05000000", "06000000", "07000000", "08000000", "09000000", "0A000000", "0B000000", "0C000000", "0D000000", "0E000000", "0F000000", "10000000", "11000000", "12000000", "13000000", "14000000", "15000000", "16000000", "17000000", "18000000", "19000000", "1A000000", "1B000000", "1C000000", "1D000000", "1E000000", "1F000000", "20000000", "21000000", "22000000", "23000000", "24000000", "25000000", "26000000", "27000000", "28000000", "29000000", "2A000000", "2B000000", "2C000000", "2D000000", "2E000000", "2F000000", "30000000", "31000000", "32000000", "33000000", "34000000", "35000000", "36000000", "37000000", "38000000", "39000000", "3A000000", "3B000000", "3C000000", "3D000000", "3E000000", "3F000000", "40000000", "41000000", "42000000", "43000000", "44000000", "45000000", "46000000", "47000000", "48000000", "49000000", "4A000000", "4B000000", "4C000000", "4D000000", "4E000000", "4F000000", "50000000", "51000000", "52000000", "53000000", "54000000", "55000000", "56000000", "57000000", "58000000", "59000000", "5A000000", "5B000000", "5C000000", "5D000000", "5E000000", "5F000000", "60000000", "61000000", "62000000", "63000000", "64000000", "65000000", "66000000", "67000000", "68000000", "69000000", "6A000000", "6B000000", "6D000000", "6E000000", "6F000000", "70000000", "71000000", "72000000", "73000000", "74000000", "75000000", "76000000", "77000000", "78000000", "79000000", "7A000000", "7B000000", "7C000000", "7D000000", "7E000000", "7F000000", "80000000", "81000000", "82000000", "83000000", "84000000", "85000000", "86000000", "87000000", "88000000", "89000000", "8A000000", "8B000000", "8C000000", "8E000000", "90000000", "91000000", "92000000", "94000000", "95000000", "96000000", "97000000", "98000000", "99000000", "9A000000", "9B000000", "9C000000", "9D000000", "9E000000", "9F000000", "A0000000", "A1000000", "A2000000", "A3000000", "A4000000", "A5000000", "A6000000", "A7000000", "A8000000", "A9000000", "AA000000", "AB000000", "AC000000", "AD000000", "AE000000", "B0000000", "B3000000", "B4000000", "BF000000", "C1000000", "C2000000", "C7000000", "C8000000", "CD000000", "CE000000", "D3000000", "D4000000", "D5000000", "D6000000", "D7000000", "D9000000", "E3000000", "E4000000", "E7000000", "E8000000", "E9000000", "EA000000", "EB000000", "F0000000", "F1000000", "F2000000", "F5000000", "F6000000", "F7000000", "FA000000", "FD000000", "FE000000", "FF000000", "00010000", "01010000", "02010000", "03010000", "04010000", "05010000", "06010000", "08010000", "0A010000", "0B010000", "0C010000", "0D010000", "0E010000", "0F010000", "10010000", "11010000", "12010000", "13010000", "1A010000", "1B010000", "1C010000", "1E010000", "1F010000", "22010000", "23010000", "24010000", "25010000", "26010000", "27010000", "28010000", "29010000", "2A010000", "2B010000", "2C010000", "2D010000", "2E010000", "2F010000", "30010000", "32010000", "33010000", "34010000", "35010000", "36010000", "37010000", "38010000", "39010000", "3A010000", "3C010000", "3D010000", "3E010000", "3F010000", "40010000", "41010000", "42010000", "43010000", "44010000", "70010000", "71010000", "72010000", "73010000", "74010000", "75010000", "76010000", "77010000", "78010000", "79010000", "7A010000", "7B010000", "7C010000", "7D010000", "7E010000", "7F010000", "80010000", "81010000", "82010000", "83010000", "84010000", "85010000", "86010000", "87010000", "88010000", "89010000", "8A010000", "8B010000", "8C010000", "8D010000", "8E010000", "8F010000", "90010000", "91010000", "92010000", "93010000", "94010000", "95010000", "96010000", "97010000", "98010000", "99010000", "9A010000", "9B010000", "9C010000", "9D010000", "9E010000", "9F010000", "A0010000", "A1010000", "A2010000", "A3010000", "A4010000", "A5010000", "A6010000", "A7010000", "A8010000", "A9010000", "AA010000", "AB010000", "AC010000", "AD010000", "AE010000", "AF010000", "B0010000", "B1010000", "B2010000", "B3010000", "B4010000", "B5010000", "B6010000", "B7010000", "B8010000", "B9010000", "BA010000", "BB010000", "BC010000", "BD010000", "BE010000", "BF010000", "C0010000", "C1010000", "C2010000", "C3010000", "C4010000", "C5010000", "C6010000", "C7010000", "C8010000", "C9010000", "CA010000", "CB010000", "CC010000", "F2010000", "F3010000", "F4010000", "F5010000", "F6010000", "F7010000", "F8010000", "F9010000", "FA010000", "FB010000", "FC010000", "FD010000", "FE010000", "FF010000", "00020000", "01020000", "03020000", "04020000", "05020000", "06020000", "07020000", "08020000", "09020000", "0A020000", "0B020000", "0C020000", "0D020000", "0E020000", "0F020000", "10020000", "11020000", "12020000", "13020000", "14020000", "15020000", "16020000", "56020000", "57020000", "58020000", "59020000", "5A020000", "5B020000", "5C020000", "5D020000", "5E020000", "5F020000", "60020000", "61020000", "62020000", "63020000", "64020000", "65020000", "66020000", "67020000", "68020000", "69020000", "6A020000", "6B020000", "6D020000", "6E020000", "71020000", "7A020000", "7B020000", "7C020000", "7D020000", "7E020000", "7F020000", "80020000", "81020000", "82020000", "83020000", "84020000", "85020000", "86020000", "87020000", "88020000", "89020000", "8A020000", "8B020000", "8C020000", "8D020000", "8E020000", "8F020000", "90020000", "91020000", "92020000", "93020000", "94020000", "96020000", "98020000", "99020000", "9A020000", "9B020000", "9C020000", "9D020000", "9E020000", "9F020000", "A0020000", "A1020000", "A2020000", "A3020000", "A4020000", "A5020000", "A7020000", "A8020000", "A9020000", "AA020000", "AB020000", "AC020000", "AD020000", "AF020000", "B0020000", "B1020000", "B2020000", "B3020000", "B4020000", "B5020000", "B6020000", "B7020000", "B8020000", "B9020000", "CF020000"];
    oculosFEMININO = ["01000200", "02000200", "03000200", "04000200", "05000200", "06000200", "07000200", "08000200", "09000200", "0A000200", "0B000200", "0C000200", "0D000200", "0E000200", "0F000200", "10000200", "11000200", "12000200", "14000200", "15000200", "16000200", "17000200", "18000200", "19000200", "1A000200", "1B000200", "1C000200", "1D000200", "1E000200", "1F000200", "20000200", "21000200", "22000200", "23000200", "24000200", "25000200", "26000200", "27000200", "28000200", "2A000200", "2B000200", "2C000200", "2D000200", "2E000200", "2F000200", "30000200", "31000200", "32000200", "33000200", "34000200", "35000200", "36000200", "37000200", "38000200", "39000200", "3A000200", "3B000200", "3C000200", "3D000200", "3F000200", "41000200", "42000200", "43000200", "48000200", "49000200", "4E000200", "55000200", "56000200", "57000200", "58000200", "5A000200", "5C000200", "5D000200", "5E000200", "5F000200", "60000200", "61000200", "65000200", "66000200", "68000200", "69000200", "6A000200", "6E000200", "6F000200", "70000200", "72000200", "75000200", "76000200", "77000200", "79000200", "7A000200", "7B000200", "7C000200", "7D000200", "7E000200", "7F000200", "80000200", "81000200", "83000200", "84000200", "85000200", "86000200", "87000200", "88000200", "8B000200", "8C000200", "8D000200", "8E000200", "8F000200", "90000200", "91000200", "92000200", "93000200", "94000200", "95000200", "96000200", "97000200", "98000200", "99000200", "9A000200", "9B000200", "9C000200", "9D000200", "9E000200", "9F000200", "A0000200", "A1000200", "A2000200", "A3000200", "A4000200", "A5000200", "A6000200", "A7000200", "A8000200", "A9000200", "AA000200", "AB000200", "AC000200", "AD000200", "AE000200", "AF000200", "B0000200", "B1000200", "B2000200", "B3000200", "B4000200", "B5000200", "B6000200", "B7000200", "B8000200", "B9000200", "BA000200", "18010200", "19010200", "1A010200", "1C010200", "1D010200", "1E010200", "1F010200", "20010200", "21010200", "23010200", "24010200", "26010200", "27010200", "28010200", "29010200", "2A010200", "2C010200", "2D010200"];
    especialUNISEX = ["01800300", "02800300", "03800300", "04800300", "05800300", "06800300", "07800300", "08800300", "09800300", "0A800300", "0B800300", "0C800300", "0D800300", "0E800300", "0F800300", "10800300", "11800300", "12800300", "13800300", "14800300", "15800300", "16800300", "17800300", "18800300", "19800300", "1A800300", "1B800300", "1C800300", "1D800300", "1E800300", "1F800300", "20800300", "21800300", "22800300", "23800300", "24800300", "25800300", "26800300", "27800300", "28800300", "29800300", "2A800300", "2B800300", "2C800300", "2D800300", "2E800300", "2F800300", "30800300", "31800300", "32800300", "33800300", "34800300", "35800300", "36800300", "37800300", "38800300", "39800300", "3A800300", "3B800300", "3C800300", "3D800300", "3E800300", "3F800300", "41800300", "42800300", "43800300", "44800300", "45800300", "46800300", "47800300", "48800300", "49800300", "4B800300", "4C800300", "4D800300", "4E800300", "4F800300", "50800300", "51800300", "52800300", "53800300", "54800300", "55800300", "56800300", "57800300", "58800300", "5B800300", "5C800300", "5D800300", "5E800300", "62800300", "63800300", "64800300", "65800300", "66800300", "67800300", "68800300", "69800300", "6A800300", "6B800300", "6C800300", "6D800300", "6E800300", "6F800300", "70800300", "71800300", "72800300", "73800300", "74800300", "75800300", "76800300", "77800300", "78800300", "79800300", "7A800300", "7B800300", "7C800300", "7D800300", "7E800300", "7F800300", "80800300", "81800300", "82800300", "83800300", "84800300", "85800300", "86800300", "87800300", "88800300", "89800300", "8A800300", "98800300", "99800300", "9A800300", "9B800300", "9C800300", "9D800300", "9E800300", "9F800300", "A0800300", "A1800300", "A2800300", "A4800300", "A5800300", "A6800300", "A7800300", "A8800300", "A9800300", "AA800300", "AB800300", "AC800300", "AD800300", "AE800300", "AF800300", "B0800300", "B1800300", "B2800300", "B3800300", "B4800300", "B5800300", "B6800300", "B7800300", "BD800300", "BE800300", "BF800300", "C0800300", "C1800300", "C2800300", "C4800300", "C5800300", "C6800300", "C9800300", "CA800300", "CB800300", "CC800300", "CD800300", "CE800300", "CF800300", "D0800300", "D1800300", "D2800300", "D3800300", "D4800300", "D5800300", "D6800300", "D7800300", "D8800300", "D9800300", "DA800300", "DB800300", "DC800300", "DD800300", "DE800300", "DF800300", "E0800300", "E1800300", "F7800300", "F8800300", "FB800300", "0B810300", "0F810300", "18810300", "19810300", "1A810300", "1F810300", "24810300", "2D810300", "2E810300", "36810300", "38810300", "39810300", "3A810300", "3B810300", "3C810300", "3D810300", "3E810300", "3F810300", "41810300", "42810300", "46810300", "49810300", "4A810300", "4E810300", "4F810300", "50810300", "51810300", "52810300", "53810300", "54810300", "55810300", "56810300", "57810300", "58810300", "5B810300", "5C810300", "5F810300", "60810300", "61810300", "62810300", "63810300", "6B810300", "6C810300", "6F810300", "70810300", "71810300", "72810300", "73810300", "74810300", "75810300", "76810300", "79810300", "7A810300", "7C810300", "7E810300", "7F810300", "80810300", "81810300", "82810300", "83810300", "84810300", "85810300", "86810300", "87810300", "88810300", "89810300", "8A810300", "8B810300", "8C810300", "8D810300", "8E810300", "8F810300", "90810300", "91810300", "92810300", "93810300", "94810300", "96810300", "97810300", "99810300", "9A810300", "9B810300", "9C810300", "9D810300", "9E810300", "9F810300", "A0810300", "A1810300", "A4810300", "A5810300", "A6810300", "A7810300", "A8810300", "AA810300", "AB810300", "AC810300", "AD810300", "AE810300", "AF810300", "B0810300", "B1810300", "B2810300", "B3810300", "B4810300", "B5810300", "B6810300", "B7810300", "B8810300", "B9810300", "BA810300", "BB810300", "BC810300", "BD810300", "BE810300", "BF810300", "C0810300", "C1810300", "C2810300", "C3810300", "C4810300", "C5810300", "C6810300", "C7810300", "C8810300", "C9810300", "CA810300", "CB810300", "CC810300", "CD810300", "CE810300", "CF810300", "D0810300", "D1810300", "D2810300", "D3810300", "D4810300", "D5810300", "F6810300", "F7810300", "F8810300", "F9810300", "FA810300", "FB810300", "FC810300", "FD810300", "FE810300", "FF810300", "00820300", "01820300", "02820300", "03820300", "04820300", "05820300", "06820300", "07820300", "08820300", "09820300", "0A820300", "0B820300", "0C820300", "0D820300", "0E820300", "0F820300", "10820300", "11820300", "12820300", "13820300", "14820300", "15820300", "16820300", "17820300", "18820300", "19820300", "1A820300", "1B820300", "1C820300", "1D820300", "1E820300", "1F820300", "20820300", "21820300", "22820300", "23820300", "24820300", "25820300", "26820300", "27820300", "28820300", "29820300", "2A820300", "2B820300", "2C820300", "2D820300", "2E820300", "2F820300", "30820300", "31820300", "32820300", "33820300", "34820300", "35820300", "36820300", "37820300", "38820300", "39820300", "3A820300", "3B820300", "3C820300", "3D820300", "3E820300", "3F820300", "40820300", "41820300", "42820300", "43820300", "44820300", "45820300", "46820300", "47820300", "48820300", "49820300", "4A820300", "4B820300", "4C820300", "4D820300", "4E820300", "4F820300", "50820300", "51820300", "52820300", "60820300", "6A820300", "6B820300", "7A820300", "7B820300", "7C820300", "7D820300", "82820300", "84820300", "85820300", "88820300", "89820300", "8A820300", "8B820300", "8C820300", "8D820300", "8E820300", "8F820300", "90820300", "91820300", "92820300", "93820300", "94820300", "95820300", "96820300", "97820300", "98820300", "99820300", "9A820300", "9B820300", "9C820300", "9D820300", "9E820300", "9F820300", "A0820300", "A1820300", "AA820300", "AB820300", "AC820300", "AD820300", "AE820300", "AF820300"];
    chapel = random.choice(chapelMASCULINO)
    roupa = random.choice(roupaMASCULINO)
    oculos = random.choice(oculosMASCULINO)
    especial = random.choice(especialUNISEX)
    if genero == "f":
        chapel = random.choice(chapelFEMININO)
        roupa = random.choice(roupaFEMININO)
        oculos = random.choice(oculosFEMININO)
    return "" + chapel + "" + roupa + "" + oculos + "" + especial + ""
    

def Converter_BYTES_para_HEX(input_bytes):
    return "".join("{:02X}".format(b) for b in input_bytes)


def Converter_INT_para_BYTES(input_integer, size):
    output_bytes = bytearray()
    for i in range(size):
        output_bytes.append(input_integer & 0xff)
        input_integer = input_integer >> 8
    return output_bytes


def Converter_INT_para_BYTES2(input_integer, size, big_endian=False):
    output_bytes = bytearray()
    if big_endian:
        for i in range(size):
            output_bytes.insert(0, input_integer & 0xff)
            input_integer = input_integer >> 8
    else:
        for i in range(size):
            output_bytes.append(input_integer & 0xff)
            input_integer = input_integer >> 8
    return output_bytes


def Converter_BYTES_para_INT(input_bytes, size):
    if len(input_bytes) < size:
        #print("bytes_to_int: tamanho solicitado e menor que bytes de entrada")
        return 0
    output_int = 0
    for i in range(size):
        output_int |= input_bytes[i] << (i * 8)
    return output_int


def left_rotate(n, b):
    return ((n << b) | (n >> (32 - b))) & 0xffffffff


def sha0_process_block(chunk):
    w = []
    for i in range(16):
        chunk_byte1 = chunk[i * 4 + 3] << (0 * 8)
        chunk_byte2 = chunk[i * 4 + 2] << (1 * 8)
        chunk_byte3 = chunk[i * 4 + 1] << (2 * 8)
        chunk_byte4 = chunk[i * 4 + 0] << (3 * 8)
        w.append(chunk_byte1 | chunk_byte2 | chunk_byte3 | chunk_byte4)
    w.extend(bytes.fromhex("00" * (80 - 16)))
    for i in range(16, 80):
        w[i] = left_rotate(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 0)
    sha_h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]
    a = sha_h[0]
    b = sha_h[1]
    c = sha_h[2]
    d = sha_h[3]
    e = sha_h[4]
    for i in range(80):
        k = 0
        f = 0
        if 0 <= i <= 19:
            f = d ^ (b & (c ^ d))
            k = 0x5A827999
        elif 20 <= i <= 39:
            f = b ^ c ^ d
            k = 0x6ED9EBA1
        elif 40 <= i <= 59:
            f = (b & c) | (b & d) | (c & d)
            k = 0x8F1BBCDC
        elif 60 <= i <= 79:
            f = b ^ c ^ d
            k = 0xCA62C1D6
        a, b, c, d, e = ((left_rotate(a, 5) + f + e + k + w[i]) & 0xffffffff, a, left_rotate(b, 30), c, d)
    sha_h[0] = (sha_h[0] + a) & 0xffffffff
    sha_h[1] = (sha_h[1] + b) & 0xffffffff
    sha_h[2] = (sha_h[2] + c) & 0xffffffff
    sha_h[3] = (sha_h[3] + d) & 0xffffffff
    sha_h[4] = (sha_h[4] + e) & 0xffffffff
    result = bytearray()
    for block_index in range(4):
        result.extend(Converter_INT_para_BYTES(sha_h[block_index], 4))
    return result


def get_dynamic_key(username, password, auth_token):
    sha_state = bytearray()
    sha_state.extend(username.encode("ascii"))
    sha_state.extend(password.encode("ascii"))
    sha_state.extend(auth_token)
    message_bit_length = len(sha_state) * 8
    sha_state.append(0x80)  # append one bit
    sha_state.extend(bytes.fromhex("00" * (62 - len(sha_state))))  # 64 byte chunk, subtract 2 to store length (WORD)
    sha_state.append(message_bit_length >> 8)
    sha_state.append(message_bit_length & 0xFF)
    return sha0_process_block(sha_state)


def aes_decrypt_block(block, key):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.decrypt(block)


def aes_encrypt_block(block, key):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(block)


def gunbound_static_decrypt(block):
    return aes_decrypt_block(block, bytes.fromhex("FFB3B3BEAE97AD83B9610E23A43C2EB0"))


def gunbound_dynamic_decrypt_raw(blocks, username, password, auth_token):
    key = get_dynamic_key(username, password, auth_token)
    cipher = AES.new(key, AES.MODE_ECB)
    plain_unprocessed_bytes = cipher.decrypt(blocks)
    return plain_unprocessed_bytes


def gunbound_dynamic_encrypt_raw(plain_bytes, username, password, auth_token):
    key = get_dynamic_key(username, password, auth_token)
    cipher = AES.new(key, AES.MODE_ECB)
    encrypted_bytes = cipher.encrypt(plain_bytes)
    return encrypted_bytes


def gunbound_dynamic_decrypt(blocks, username, password, auth_token, command):
    packet_command = 0x8631607E + command  # originally command - 0x79CE9F82, but inverted to avoid negative ops
    raw = gunbound_dynamic_decrypt_raw(blocks, username, password, auth_token)
    processed = bytearray()
    current_block_command = 0
    for i in range(len(blocks)):
        internal_128_bit_index = i % 16
        if internal_128_bit_index < 4:
            current_block_command |= raw[i] << internal_128_bit_index * 8
            if internal_128_bit_index == 3:
                if current_block_command != packet_command:
                    print("gunbound_dynamic_decrypt: incompatibilidade de soma de verificacao de comando")
                current_block_command = 0
        else:
            processed.append(raw[i])
    return processed


def gunbound_dynamic_encrypt(plain_bytes, username, password, auth_token, command):
    if len(plain_bytes) % 12 != 0:
        print("gunbound_dynamic_encrypt: bytes nao estao alinhados ao limite de 12 bytes")
        return bytes.fromhex("DEADBEEF")
    packet_command = 0x8631607E + command  # originally command - 0x79CE9F82, but inverted to avoid negative ops
    packet_command_bytes = bytearray()
    packet_command_bytes.append((packet_command >> 0) & 0xFF)
    packet_command_bytes.append((packet_command >> 8) & 0xFF)
    packet_command_bytes.append((packet_command >> 16) & 0xFF)
    packet_command_bytes.append((packet_command >> 24) & 0xFF)
    processed = bytearray()
    for i in range(len(plain_bytes)):
        if i % 12 == 0:
            processed.extend(packet_command_bytes)
        processed.append(plain_bytes[i])
    encrypted_bytes = gunbound_dynamic_encrypt_raw(processed, username, password, auth_token)
    return encrypted_bytes


def Gerar_Sequencia(sum_packet_length):
    return (((sum_packet_length * 0x43FD) & 0xFFFF) - 0x53FD) & 0xFFFF


def Preencher_BYTES(input_bytes, desired_size):
    output = bytearray()
    output.extend(input_bytes)
    output.extend(bytearray.fromhex("00" * (desired_size - len(output))))
    return output


def truncate_bytes(input_bytes, desired_size):
    if len(input_bytes) > desired_size:
        return input_bytes[:desired_size]


def Redimensionar_BYTES(input_bytes, desired_size):
    if len(input_bytes) > desired_size:
        return input_bytes[:desired_size]
    else:
        return Preencher_BYTES(input_bytes, desired_size)


def Decodificar_STRING(input_bytes):
    result = ""
    for input_byte in input_bytes:
        if input_byte != 0:
            result += chr(input_byte)
        else:
            return result
    return result


def Converter_IP_para_BYTES(in_ip):
    ip_bytes = bytearray()
    ip_bytes.extend(map(int, in_ip.split('.')))
    return ip_bytes


def Encontrar_Posicao_Da_Sala(in_world_room):
    for index in range(0xFF):
        index_is_occupied = False
        for room_item in in_world_room:
            if room_item.room_id == index:
                index_is_occupied = True
                break
        if not index_is_occupied:
            return index
    print("Nenhum ID de sala disponivel")
    return 0


def Encontrar_Espaco_Na_Sala(in_room):
    for index in range(0x10):
        index_is_occupied = False
        for session_item in in_room.player_sessions:
            if session_item.room_slot == index:
                index_is_occupied = True
                break
        if not index_is_occupied:
            return index
    print("Nao ha slots de sala disponiveis")
    return 0


def Encontrar_Equipe_Na_Sala(in_room):
    team_a_size = 0
    team_b_size = 0
    for session_item in in_room.player_sessions:
        if session_item.room_team == 0:
            team_a_size += 1
        else:
            team_b_size += 1

    if team_a_size > team_b_size:
        return 1
    else:
        return 0


def Encontrar_Sala_Por_ID(in_world_room, room_id):
    for room_item in in_world_room:
        if room_item.room_id == room_id:
            return room_item
    return None


def Encontrar_Sala_Por_Usuario(in_world_room, in_username):
    for room_item in in_world_room:
        for player in room_item.player_sessions:
            if player.user.username == in_username:
                return room_item
    return None


def Remover_Sessao(in_world_room, in_username):
    for room_item in in_world_room:
        for player_index in range(len(room_item.player_sessions)):
            if room_item.player_sessions[player_index].user.username == in_username:
                room_item.player_sessions.pop(player_index)
                return True
    return False


def Remover_Salas_Vazias(in_world_room):
    cleanup_still_required = True
    while cleanup_still_required:
        for in_room_index in range(len(in_world_room)):
            if len(in_world_room[in_room_index].player_sessions) == 0:
                in_world_room.pop(in_room_index)
                break
        else:
            cleanup_still_required = False


def Gerar_Valor_Da_Funcao(effect_flags):
    result_function_out: int = 0
    for effect_flag in effect_flags:
        result_function_out |= effect_flag
    return result_function_out


def Carregar_Usuarios(in_username):
    
    user_instances = []
    avatar_random = Gerar_Avatar_Random("m")
    if in_username != 0:
        user_instance: Usuario = Usuario(in_username, "HUMANO", randint(-4, 20))
        user_instance.avatar_equipped = bytes.fromhex("" + avatar_random[8:12] + "" + avatar_random[0:4] + "" + avatar_random[16:20] + "" + avatar_random[24:28] + "")
        user_instance.avatar_inventory = [bytes.fromhex(avatar_random[0:8]),bytes.fromhex(avatar_random[8:16]),bytes.fromhex(avatar_random[16:24]),bytes.fromhex(avatar_random[24:32])]
        user_instances.append(user_instance)

    arquivo_bots = "Temporarios\Bots.txt";
    json_bots = "[\n{\"id\": \"Jesus\", \"genero\": \"m\"},\n{\"id\": \"Lucas\", \"genero\": \"m\"},\n{\"id\": \"Ricardo\", \"genero\": \"m\"},\n{\"id\": \"Evandro\", \"genero\": \"m\"},\n{\"id\": \"Alex\", \"genero\": \"m\"},\n{\"id\": \"Charlie\", \"genero\": \"m\"},\n{\"id\": \"Bruce\", \"genero\": \"m\"},\n{\"id\": \"Thiago\", \"genero\": \"m\"},\n{\"id\": \"Lopes\", \"genero\": \"m\"},\n{\"id\": \"Algusto\", \"genero\": \"m\"},\n{\"id\": \"Thais\", \"genero\": \"f\"},\n{\"id\": \"Joana\", \"genero\": \"f\"},\n{\"id\": \"Cris\", \"genero\": \"f\"},\n{\"id\": \"Tati\", \"genero\": \"f\"},\n{\"id\": \"Debora\", \"genero\": \"f\"},\n{\"id\": \"Adriana\", \"genero\": \"f\"},\n{\"id\": \"Rita\", \"genero\": \"f\"},\n{\"id\": \"Patricia\", \"genero\": \"f\"},\n{\"id\": \"Maria\", \"genero\": \"f\"},\n{\"id\": \"Amanda\", \"genero\": \"f\"}\n]"
    if os.path.isfile(arquivo_bots) and os.access(arquivo_bots, os.R_OK):

        with open(arquivo_bots) as data_text:
            data_bots = json.load(data_text)
            
    else:
        
        data_bots = json.loads(json_bots)
        
        with open(arquivo_bots, "w") as f:
            f.write(json_bots)
            
    for json_row in data_bots:
        user_instance: Usuario = Usuario(json_row["id"], "BOT", randint(-4, 20))
        genero = "0080008000800000"
        if json_row["genero"] == "f":
            genero = "0000000000000000"
        user_instance.avatar_equipped = bytes.fromhex(genero)
        user_instances.append(user_instance) 
    


    arquivo_contas = "Temporarios\Contas.txt";
    if os.path.isfile(arquivo_contas) and os.access(arquivo_contas, os.R_OK):
        
        with open(arquivo_contas, encoding="utf8") as user_data_text:
            data_users = json.load(user_data_text)
            for data_user in data_users:
                user_instance: Usuario = Usuario(data_user["id"], data_user["cla"], data_user["rank"])
                user_instance.avatar_equipped = bytes.fromhex(data_user["avatar_equipado"])
                for user_avatar_inventoryitem in data_user["avatar_comprado"]:
                    user_instance.avatar_inventory.append(bytes.fromhex(user_avatar_inventoryitem))
                user_instances.append(user_instance)
    
    else:
        
        with open(arquivo_contas, "w") as f:
            f.write("[]")
    
    return user_instances


def Encontrar_Usuario_Por_Nome(in_world_user, in_username):
    for user_item in in_world_user:
        if user_item.username == in_username:
            return user_item
    return None


def Converter_para_JSON(self):
    return json.dumps(user_to_serializable(self))


def user_to_serializable(in_user):
    data_to_serialize = {}
    data_to_serialize["id"] = in_user.username
    data_to_serialize["cla"] = in_user.guild
    data_to_serialize["rank"] = in_user.rank_current
    data_to_serialize["avatar_equipado"] = Converter_BYTES_para_HEX(in_user.avatar_equipped)
    inventory_to_serialize = []
    for avatar_item in in_user.avatar_inventory:
        inventory_to_serialize.append(Converter_BYTES_para_HEX(avatar_item))
    data_to_serialize["avatar_comprado"] = inventory_to_serialize
    return data_to_serialize


def Salvar_Modificacoes_Dos_Usuarios(in_user_list, address):
    
    arquivo_contas = "Temporarios\Contas.txt";
    
    users_to_serialize = []
    for user_item in in_user_list:
        if user_item.guild != "ADMIN" and user_item.guild != "BOT":
            users_to_serialize.append(user_to_serializable(user_item))
    print("SERVIDOR DO JOGO: " + str(address) + " " + json.dumps(users_to_serialize))
    with open(arquivo_contas, "w") as data_file_handle:
        data_file_handle.write(json.dumps(users_to_serialize))
    print("SERVIDOR DO JOGO: " + str(address) + " Salvamento concluido")


def Carregar_Informacoes_Do_Mapa():

    arquivo_mapas = "Temporarios\Mapas.txt";
    json_mapas = "[\n{\"map_id\": 0,\"map_name_en\": \"CAVE (RANDOM)\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 183, \"x_max\": 358, \"y\": null}, {\"slot_index\": 1, \"x_min\": 476, \"x_max\": 668, \"y\": null}, {\"slot_index\": 2, \"x_min\": 757, \"x_max\": 850, \"y\": null}, {\"slot_index\": 3, \"x_min\": 899, \"x_max\": 1064, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1157, \"x_max\": 1239, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1303, \"x_max\": 1366, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1445, \"x_max\": 1562, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1634, \"x_max\": 1634, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 608, \"x_max\": 682, \"y\": null}, {\"slot_index\": 1, \"x_min\": 682, \"x_max\": 756, \"y\": null}, {\"slot_index\": 2, \"x_min\": 756, \"x_max\": 828, \"y\": null}, {\"slot_index\": 3, \"x_min\": 828, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 978, \"y\": null}, {\"slot_index\": 5, \"x_min\": 978, \"x_max\": 1050, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1050, \"x_max\": 1122, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1122, \"x_max\": 1192, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 608, \"x_max\": 682, \"y\": null}, {\"slot_index\": 1, \"x_min\": 682, \"x_max\": 756, \"y\": null}, {\"slot_index\": 2, \"x_min\": 756, \"x_max\": 828, \"y\": null}, {\"slot_index\": 3, \"x_min\": 828, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 978, \"y\": null}, {\"slot_index\": 5, \"x_min\": 978, \"x_max\": 1050, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1050, \"x_max\": 1122, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1122, \"x_max\": 1192, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 608, \"x_max\": 682, \"y\": null}, {\"slot_index\": 1, \"x_min\": 682, \"x_max\": 756, \"y\": null}, {\"slot_index\": 2, \"x_min\": 756, \"x_max\": 828, \"y\": null}, {\"slot_index\": 3, \"x_min\": 828, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 978, \"y\": null}, {\"slot_index\": 5, \"x_min\": 978, \"x_max\": 1050, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1050, \"x_max\": 1122, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1122, \"x_max\": 1192, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 608, \"x_max\": 682, \"y\": null}, {\"slot_index\": 1, \"x_min\": 682, \"x_max\": 756, \"y\": null}, {\"slot_index\": 2, \"x_min\": 756, \"x_max\": 828, \"y\": null}, {\"slot_index\": 3, \"x_min\": 828, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 978, \"y\": null}, {\"slot_index\": 5, \"x_min\": 978, \"x_max\": 1050, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1050, \"x_max\": 1122, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1122, \"x_max\": 1192, \"y\": null}]},\n{\"map_id\": 1,\"map_name_en\": \"MIRAMO TOWN\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 154, \"x_max\": 350, \"y\": null}, {\"slot_index\": 1, \"x_min\": 350, \"x_max\": 536, \"y\": null}, {\"slot_index\": 2, \"x_min\": 536, \"x_max\": 722, \"y\": null}, {\"slot_index\": 3, \"x_min\": 722, \"x_max\": 924, \"y\": null}, {\"slot_index\": 4, \"x_min\": 924, \"x_max\": 1112, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1112, \"x_max\": 1304, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1304, \"x_max\": 1496, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1496, \"x_max\": 1676, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 231, \"x_max\": 231, \"y\": null}, {\"slot_index\": 1, \"x_min\": 484, \"x_max\": 484, \"y\": null}, {\"slot_index\": 2, \"x_min\": 776, \"x_max\": 776, \"y\": null}, {\"slot_index\": 3, \"x_min\": 796, \"x_max\": 796, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1020, \"x_max\": 1020, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1235, \"x_max\": 1235, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1393, \"x_max\": 1393, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1528, \"x_max\": 1528, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 154, \"x_max\": 350, \"y\": null}, {\"slot_index\": 1, \"x_min\": 350, \"x_max\": 536, \"y\": null}, {\"slot_index\": 2, \"x_min\": 536, \"x_max\": 722, \"y\": null}, {\"slot_index\": 3, \"x_min\": 722, \"x_max\": 924, \"y\": null}, {\"slot_index\": 4, \"x_min\": 924, \"x_max\": 1112, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1112, \"x_max\": 1304, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1304, \"x_max\": 1496, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1496, \"x_max\": 1676, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 154, \"x_max\": 350, \"y\": null}, {\"slot_index\": 1, \"x_min\": 350, \"x_max\": 536, \"y\": null}, {\"slot_index\": 2, \"x_min\": 536, \"x_max\": 722, \"y\": null}, {\"slot_index\": 3, \"x_min\": 722, \"x_max\": 924, \"y\": null}, {\"slot_index\": 4, \"x_min\": 924, \"x_max\": 1112, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1112, \"x_max\": 1304, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1304, \"x_max\": 1496, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1496, \"x_max\": 1676, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 154, \"x_max\": 350, \"y\": null}, {\"slot_index\": 1, \"x_min\": 350, \"x_max\": 536, \"y\": null}, {\"slot_index\": 2, \"x_min\": 536, \"x_max\": 722, \"y\": null}, {\"slot_index\": 3, \"x_min\": 722, \"x_max\": 924, \"y\": null}, {\"slot_index\": 4, \"x_min\": 924, \"x_max\": 1112, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1112, \"x_max\": 1304, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1304, \"x_max\": 1496, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1496, \"x_max\": 1676, \"y\": null}]},\n{\"map_id\": 2,\"map_name_en\": \"NIRVANA\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 52, \"x_max\": 240, \"y\": null}, {\"slot_index\": 1, \"x_min\": 240, \"x_max\": 424, \"y\": null}, {\"slot_index\": 2, \"x_min\": 424, \"x_max\": 612, \"y\": null}, {\"slot_index\": 3, \"x_min\": 612, \"x_max\": 800, \"y\": null}, {\"slot_index\": 4, \"x_min\": 800, \"x_max\": 988, \"y\": null}, {\"slot_index\": 5, \"x_min\": 988, \"x_max\": 1174, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1174, \"x_max\": 1376, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1376, \"x_max\": 1550, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 475, \"x_max\": 475, \"y\": null}, {\"slot_index\": 1, \"x_min\": 866, \"x_max\": 866, \"y\": null}, {\"slot_index\": 2, \"x_min\": 1118, \"x_max\": 1118, \"y\": null}, {\"slot_index\": 3, \"x_min\": 689, \"x_max\": 689, \"y\": null}, {\"slot_index\": 4, \"x_min\": 946, \"x_max\": 946, \"y\": null}, {\"slot_index\": 5, \"x_min\": 623, \"x_max\": 623, \"y\": 1000}, {\"slot_index\": 6, \"x_min\": 771, \"x_max\": 771, \"y\": 1000}, {\"slot_index\": 7, \"x_min\": 1023, \"x_max\": 1100, \"y\": 1053}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 52, \"x_max\": 240, \"y\": null}, {\"slot_index\": 1, \"x_min\": 240, \"x_max\": 424, \"y\": null}, {\"slot_index\": 2, \"x_min\": 424, \"x_max\": 612, \"y\": null}, {\"slot_index\": 3, \"x_min\": 612, \"x_max\": 800, \"y\": null}, {\"slot_index\": 4, \"x_min\": 800, \"x_max\": 988, \"y\": null}, {\"slot_index\": 5, \"x_min\": 988, \"x_max\": 1174, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1174, \"x_max\": 1376, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1376, \"x_max\": 1550, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 52, \"x_max\": 240, \"y\": null}, {\"slot_index\": 1, \"x_min\": 240, \"x_max\": 424, \"y\": null}, {\"slot_index\": 2, \"x_min\": 424, \"x_max\": 612, \"y\": null}, {\"slot_index\": 3, \"x_min\": 612, \"x_max\": 800, \"y\": null}, {\"slot_index\": 4, \"x_min\": 800, \"x_max\": 988, \"y\": null}, {\"slot_index\": 5, \"x_min\": 988, \"x_max\": 1174, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1174, \"x_max\": 1376, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1376, \"x_max\": 1550, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 52, \"x_max\": 240, \"y\": null}, {\"slot_index\": 1, \"x_min\": 240, \"x_max\": 424, \"y\": null}, {\"slot_index\": 2, \"x_min\": 424, \"x_max\": 612, \"y\": null}, {\"slot_index\": 3, \"x_min\": 612, \"x_max\": 800, \"y\": null}, {\"slot_index\": 4, \"x_min\": 800, \"x_max\": 988, \"y\": null}, {\"slot_index\": 5, \"x_min\": 988, \"x_max\": 1174, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1174, \"x_max\": 1376, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1376, \"x_max\": 1550, \"y\": null}]},\n{\"map_id\": 3,\"map_name_en\": \"METROPOLIS\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 51, \"x_max\": 219, \"y\": null}, {\"slot_index\": 1, \"x_min\": 219, \"x_max\": 498, \"y\": null}, {\"slot_index\": 2, \"x_min\": 498, \"x_max\": 732, \"y\": null}, {\"slot_index\": 3, \"x_min\": 732, \"x_max\": 897, \"y\": null}, {\"slot_index\": 4, \"x_min\": 897, \"x_max\": 1065, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1065, \"x_max\": 1302, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1302, \"x_max\": 1572, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1572, \"x_max\": 1743, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 384, \"x_max\": 384, \"y\": null}, {\"slot_index\": 1, \"x_min\": 532, \"x_max\": 532, \"y\": null}, {\"slot_index\": 2, \"x_min\": 620, \"x_max\": 620, \"y\": null}, {\"slot_index\": 3, \"x_min\": 746, \"x_max\": 746, \"y\": null}, {\"slot_index\": 4, \"x_min\": 985, \"x_max\": 985, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1111, \"x_max\": 1111, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1274, \"x_max\": 1274, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1319, \"x_max\": 1319, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 51, \"x_max\": 219, \"y\": null}, {\"slot_index\": 1, \"x_min\": 219, \"x_max\": 498, \"y\": null}, {\"slot_index\": 2, \"x_min\": 498, \"x_max\": 732, \"y\": null}, {\"slot_index\": 3, \"x_min\": 732, \"x_max\": 897, \"y\": null}, {\"slot_index\": 4, \"x_min\": 897, \"x_max\": 1065, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1065, \"x_max\": 1302, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1302, \"x_max\": 1572, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1572, \"x_max\": 1743, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 51, \"x_max\": 219, \"y\": null}, {\"slot_index\": 1, \"x_min\": 219, \"x_max\": 498, \"y\": null}, {\"slot_index\": 2, \"x_min\": 498, \"x_max\": 732, \"y\": null}, {\"slot_index\": 3, \"x_min\": 732, \"x_max\": 897, \"y\": null}, {\"slot_index\": 4, \"x_min\": 897, \"x_max\": 1065, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1065, \"x_max\": 1302, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1302, \"x_max\": 1572, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1572, \"x_max\": 1743, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 51, \"x_max\": 219, \"y\": null}, {\"slot_index\": 1, \"x_min\": 219, \"x_max\": 498, \"y\": null}, {\"slot_index\": 2, \"x_min\": 498, \"x_max\": 732, \"y\": null}, {\"slot_index\": 3, \"x_min\": 732, \"x_max\": 897, \"y\": null}, {\"slot_index\": 4, \"x_min\": 897, \"x_max\": 1065, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1065, \"x_max\": 1302, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1302, \"x_max\": 1572, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1572, \"x_max\": 1743, \"y\": null}]},\n{\"map_id\": 4,\"map_name_en\": \"SEA OF HERO\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 122, \"y\": null}, {\"slot_index\": 1, \"x_min\": 190, \"x_max\": 292, \"y\": null}, {\"slot_index\": 2, \"x_min\": 462, \"x_max\": 572, \"y\": null}, {\"slot_index\": 3, \"x_min\": 608, \"x_max\": 724, \"y\": null}, {\"slot_index\": 4, \"x_min\": 880, \"x_max\": 984, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1118, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1268, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1446, \"x_max\": 1556, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 160, \"x_max\": 160, \"y\": null}, {\"slot_index\": 1, \"x_min\": 352, \"x_max\": 352, \"y\": null}, {\"slot_index\": 2, \"x_min\": 537, \"x_max\": 537, \"y\": null}, {\"slot_index\": 3, \"x_min\": 698, \"x_max\": 698, \"y\": null}, {\"slot_index\": 4, \"x_min\": 898, \"x_max\": 898, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1056, \"x_max\": 1056, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1303, \"x_max\": 1303, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1409, \"x_max\": 1409, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 122, \"y\": null}, {\"slot_index\": 1, \"x_min\": 190, \"x_max\": 292, \"y\": null}, {\"slot_index\": 2, \"x_min\": 462, \"x_max\": 572, \"y\": null}, {\"slot_index\": 3, \"x_min\": 608, \"x_max\": 724, \"y\": null}, {\"slot_index\": 4, \"x_min\": 880, \"x_max\": 984, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1118, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1268, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1446, \"x_max\": 1556, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 122, \"y\": null}, {\"slot_index\": 1, \"x_min\": 190, \"x_max\": 292, \"y\": null}, {\"slot_index\": 2, \"x_min\": 462, \"x_max\": 572, \"y\": null}, {\"slot_index\": 3, \"x_min\": 608, \"x_max\": 724, \"y\": null}, {\"slot_index\": 4, \"x_min\": 880, \"x_max\": 984, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1118, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1268, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1446, \"x_max\": 1556, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 122, \"y\": null}, {\"slot_index\": 1, \"x_min\": 190, \"x_max\": 292, \"y\": null}, {\"slot_index\": 2, \"x_min\": 462, \"x_max\": 572, \"y\": null}, {\"slot_index\": 3, \"x_min\": 608, \"x_max\": 724, \"y\": null}, {\"slot_index\": 4, \"x_min\": 880, \"x_max\": 984, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1118, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1268, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1446, \"x_max\": 1556, \"y\": null}]},\n{\"map_id\": 5,\"map_name_en\": \"ADIUMROOT\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 230, \"y\": null}, {\"slot_index\": 1, \"x_min\": 230, \"x_max\": 428, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 640, \"y\": null}, {\"slot_index\": 3, \"x_min\": 640, \"x_max\": 874, \"y\": null}, {\"slot_index\": 4, \"x_min\": 874, \"x_max\": 1108, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1108, \"x_max\": 1340, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1340, \"x_max\": 1552, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1552, \"x_max\": 1760, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 939, \"x_max\": 939, \"y\": 771}, {\"slot_index\": 1, \"x_min\": 1030, \"x_max\": 1030, \"y\": 801}, {\"slot_index\": 2, \"x_min\": 902, \"x_max\": 902, \"y\": 869}, {\"slot_index\": 3, \"x_min\": 809, \"x_max\": 809, \"y\": 902}, {\"slot_index\": 4, \"x_min\": 989, \"x_max\": 989, \"y\": 1008}, {\"slot_index\": 5, \"x_min\": 1061, \"x_max\": 1061, \"y\": 1030}, {\"slot_index\": 6, \"x_min\": 856, \"x_max\": 856, \"y\": 1104}, {\"slot_index\": 7, \"x_min\": 763, \"x_max\": 763, \"y\": 1134}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 230, \"y\": null}, {\"slot_index\": 1, \"x_min\": 230, \"x_max\": 428, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 640, \"y\": null}, {\"slot_index\": 3, \"x_min\": 640, \"x_max\": 874, \"y\": null}, {\"slot_index\": 4, \"x_min\": 874, \"x_max\": 1108, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1108, \"x_max\": 1340, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1340, \"x_max\": 1552, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1552, \"x_max\": 1760, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 230, \"y\": null}, {\"slot_index\": 1, \"x_min\": 230, \"x_max\": 428, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 640, \"y\": null}, {\"slot_index\": 3, \"x_min\": 640, \"x_max\": 874, \"y\": null}, {\"slot_index\": 4, \"x_min\": 874, \"x_max\": 1108, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1108, \"x_max\": 1340, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1340, \"x_max\": 1552, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1552, \"x_max\": 1760, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 26, \"x_max\": 230, \"y\": null}, {\"slot_index\": 1, \"x_min\": 230, \"x_max\": 428, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 640, \"y\": null}, {\"slot_index\": 3, \"x_min\": 640, \"x_max\": 874, \"y\": null}, {\"slot_index\": 4, \"x_min\": 874, \"x_max\": 1108, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1108, \"x_max\": 1340, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1340, \"x_max\": 1552, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1552, \"x_max\": 1760, \"y\": null}]},\n{\"map_id\": 6,\"map_name_en\": \"DRAGON\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 70, \"x_max\": 188, \"y\": null}, {\"slot_index\": 1, \"x_min\": 244, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 378, \"x_max\": 490, \"y\": null}, {\"slot_index\": 3, \"x_min\": 540, \"x_max\": 618, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1182, \"x_max\": 1274, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1328, \"x_max\": 1416, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1472, \"x_max\": 1558, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1622, \"x_max\": 1718, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 434, \"x_max\": 434, \"y\": null}, {\"slot_index\": 1, \"x_min\": 521, \"x_max\": 521, \"y\": null}, {\"slot_index\": 2, \"x_min\": 591, \"x_max\": 591, \"y\": null}, {\"slot_index\": 3, \"x_min\": 860, \"x_max\": 860, \"y\": null}, {\"slot_index\": 4, \"x_min\": 975, \"x_max\": 975, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1055, \"x_max\": 1055, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1289, \"x_max\": 1289, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1440, \"x_max\": 1440, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 70, \"x_max\": 188, \"y\": null}, {\"slot_index\": 1, \"x_min\": 244, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 378, \"x_max\": 490, \"y\": null}, {\"slot_index\": 3, \"x_min\": 540, \"x_max\": 618, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1182, \"x_max\": 1274, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1328, \"x_max\": 1416, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1472, \"x_max\": 1558, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1622, \"x_max\": 1718, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 70, \"x_max\": 188, \"y\": null}, {\"slot_index\": 1, \"x_min\": 244, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 378, \"x_max\": 490, \"y\": null}, {\"slot_index\": 3, \"x_min\": 540, \"x_max\": 618, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1182, \"x_max\": 1274, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1328, \"x_max\": 1416, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1472, \"x_max\": 1558, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1622, \"x_max\": 1718, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 70, \"x_max\": 188, \"y\": null}, {\"slot_index\": 1, \"x_min\": 244, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 378, \"x_max\": 490, \"y\": null}, {\"slot_index\": 3, \"x_min\": 540, \"x_max\": 618, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1182, \"x_max\": 1274, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1328, \"x_max\": 1416, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1472, \"x_max\": 1558, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1622, \"x_max\": 1718, \"y\": null}]},\n{\"map_id\": 7,\"map_name_en\": \"COZYTOWER\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 222, \"y\": null}, {\"slot_index\": 1, \"x_min\": 222, \"x_max\": 324, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 614, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 1192, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1230, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1484, \"x_max\": 1590, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1590, \"x_max\": 1688, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 203, \"x_max\": 203, \"y\": null}, {\"slot_index\": 1, \"x_min\": 411, \"x_max\": 411, \"y\": null}, {\"slot_index\": 2, \"x_min\": 611, \"x_max\": 611, \"y\": null}, {\"slot_index\": 3, \"x_min\": 810, \"x_max\": 810, \"y\": null}, {\"slot_index\": 4, \"x_min\": 996, \"x_max\": 996, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1193, \"x_max\": 1193, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1394, \"x_max\": 1394, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1592, \"x_max\": 1592, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 222, \"y\": null}, {\"slot_index\": 1, \"x_min\": 222, \"x_max\": 324, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 614, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 1192, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1230, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1484, \"x_max\": 1590, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1590, \"x_max\": 1688, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 222, \"y\": null}, {\"slot_index\": 1, \"x_min\": 222, \"x_max\": 324, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 614, \"x_max\": 902, \"y\": null}, {\"slot_index\": 4, \"x_min\": 902, \"x_max\": 1192, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1230, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1484, \"x_max\": 1590, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1590, \"x_max\": 1688, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 324, \"y\": null}, {\"slot_index\": 1, \"x_min\": 120, \"x_max\": 324, \"y\": null}, {\"slot_index\": 2, \"x_min\": 428, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 3, \"x_min\": 428, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 4, \"x_min\": 428, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 5, \"x_min\": 428, \"x_max\": 1378, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1484, \"x_max\": 1688, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1484, \"x_max\": 1688, \"y\": null}]},\n{\"map_id\": 8,\"map_name_en\": \"DUMMY SLOPE\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 208, \"y\": null}, {\"slot_index\": 1, \"x_min\": 234, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 442, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 600, \"x_max\": 722, \"y\": null}, {\"slot_index\": 4, \"x_min\": 876, \"x_max\": 986, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1106, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1324, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1346, \"x_max\": 1472, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 308, \"x_max\": 308, \"y\": 971}, {\"slot_index\": 1, \"x_min\": 250, \"x_max\": 250, \"y\": 1081}, {\"slot_index\": 2, \"x_min\": 379, \"x_max\": 379, \"y\": 1176}, {\"slot_index\": 3, \"x_min\": 619, \"x_max\": 619, \"y\": 1191}, {\"slot_index\": 4, \"x_min\": 1257, \"x_max\": 1257, \"y\": 976}, {\"slot_index\": 5, \"x_min\": 1384, \"x_max\": 1384, \"y\": 1086}, {\"slot_index\": 6, \"x_min\": 1140, \"x_max\": 1140, \"y\": 1176}, {\"slot_index\": 7, \"x_min\": 962, \"x_max\": 962, \"y\": 1193}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 208, \"y\": null}, {\"slot_index\": 1, \"x_min\": 234, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 442, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 600, \"x_max\": 722, \"y\": null}, {\"slot_index\": 4, \"x_min\": 876, \"x_max\": 986, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1106, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1324, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1346, \"x_max\": 1472, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 208, \"y\": null}, {\"slot_index\": 1, \"x_min\": 234, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 442, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 600, \"x_max\": 722, \"y\": null}, {\"slot_index\": 4, \"x_min\": 876, \"x_max\": 986, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1106, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1324, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1346, \"x_max\": 1472, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 120, \"x_max\": 208, \"y\": null}, {\"slot_index\": 1, \"x_min\": 234, \"x_max\": 334, \"y\": null}, {\"slot_index\": 2, \"x_min\": 442, \"x_max\": 570, \"y\": null}, {\"slot_index\": 3, \"x_min\": 600, \"x_max\": 722, \"y\": null}, {\"slot_index\": 4, \"x_min\": 876, \"x_max\": 986, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1004, \"x_max\": 1106, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1324, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1346, \"x_max\": 1472, \"y\": null}]},\n{\"map_id\": 9,\"map_name_en\": \"STARDUST\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 297, \"x_max\": 451, \"y\": null}, {\"slot_index\": 1, \"x_min\": 451, \"x_max\": 592, \"y\": null}, {\"slot_index\": 2, \"x_min\": 592, \"x_max\": 741, \"y\": null}, {\"slot_index\": 3, \"x_min\": 741, \"x_max\": 903, \"y\": null}, {\"slot_index\": 4, \"x_min\": 903, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1210, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1210, \"x_max\": 1357, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1357, \"x_max\": 1507, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 210, \"x_max\": 210, \"y\": null}, {\"slot_index\": 1, \"x_min\": 297, \"x_max\": 297, \"y\": null}, {\"slot_index\": 2, \"x_min\": 774, \"x_max\": 774, \"y\": null}, {\"slot_index\": 3, \"x_min\": 765, \"x_max\": 765, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1053, \"x_max\": 1053, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1100, \"x_max\": 1100, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1458, \"x_max\": 1458, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1496, \"x_max\": 1496, \"y\": null}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 297, \"x_max\": 903, \"y\": null}, {\"slot_index\": 1, \"x_min\": 297, \"x_max\": 903, \"y\": null}, {\"slot_index\": 2, \"x_min\": 297, \"x_max\": 903, \"y\": null}, {\"slot_index\": 3, \"x_min\": 297, \"x_max\": 903, \"y\": null}, {\"slot_index\": 4, \"x_min\": 903, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 5, \"x_min\": 903, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 6, \"x_min\": 903, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 7, \"x_min\": 903, \"x_max\": 1507, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 297, \"x_max\": 451, \"y\": null}, {\"slot_index\": 1, \"x_min\": 451, \"x_max\": 592, \"y\": null}, {\"slot_index\": 2, \"x_min\": 592, \"x_max\": 741, \"y\": null}, {\"slot_index\": 3, \"x_min\": 741, \"x_max\": 903, \"y\": null}, {\"slot_index\": 4, \"x_min\": 903, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1210, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1210, \"x_max\": 1357, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1357, \"x_max\": 1507, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 1, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 2, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 3, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 4, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 5, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 6, \"x_min\": 297, \"x_max\": 1507, \"y\": null}, {\"slot_index\": 7, \"x_min\": 297, \"x_max\": 1507, \"y\": null}]},\n{\"map_id\": 10,\"map_name_en\": \"META MINE\",\"positions_a_side\": [{\"slot_index\": 0, \"x_min\": 222, \"x_max\": 408, \"y\": null}, {\"slot_index\": 1, \"x_min\": 408, \"x_max\": 568, \"y\": null}, {\"slot_index\": 2, \"x_min\": 568, \"x_max\": 728, \"y\": null}, {\"slot_index\": 3, \"x_min\": 728, \"x_max\": 900, \"y\": null}, {\"slot_index\": 4, \"x_min\": 900, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1230, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1390, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1390, \"x_max\": 1576, \"y\": null}],\"positions_b_side\": [{\"slot_index\": 0, \"x_min\": 347, \"x_max\": 347, \"y\": null}, {\"slot_index\": 1, \"x_min\": 655, \"x_max\": 655, \"y\": null}, {\"slot_index\": 2, \"x_min\": 899, \"x_max\": 899, \"y\": null}, {\"slot_index\": 3, \"x_min\": 1099, \"x_max\": 1099, \"y\": null}, {\"slot_index\": 4, \"x_min\": 1456, \"x_max\": 1456, \"y\": null}, {\"slot_index\": 5, \"x_min\": 452, \"x_max\": 452, \"y\": 1000}, {\"slot_index\": 6, \"x_min\": 821, \"x_max\": 821, \"y\": 1000}, {\"slot_index\": 7, \"x_min\": 1320, \"x_max\": 1320, \"y\": 1000}],\"positions_raw_evsw\": [{\"slot_index\": 0, \"x_min\": 222, \"x_max\": 408, \"y\": null}, {\"slot_index\": 1, \"x_min\": 408, \"x_max\": 568, \"y\": null}, {\"slot_index\": 2, \"x_min\": 568, \"x_max\": 728, \"y\": null}, {\"slot_index\": 3, \"x_min\": 728, \"x_max\": 900, \"y\": null}, {\"slot_index\": 4, \"x_min\": 900, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1230, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1390, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1390, \"x_max\": 1576, \"y\": null}],\"positions_raw_mix\": [{\"slot_index\": 0, \"x_min\": 222, \"x_max\": 408, \"y\": null}, {\"slot_index\": 1, \"x_min\": 408, \"x_max\": 568, \"y\": null}, {\"slot_index\": 2, \"x_min\": 568, \"x_max\": 728, \"y\": null}, {\"slot_index\": 3, \"x_min\": 728, \"x_max\": 900, \"y\": null}, {\"slot_index\": 4, \"x_min\": 900, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1230, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1390, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1390, \"x_max\": 1576, \"y\": null}],\"positions_raw_random\": [{\"slot_index\": 0, \"x_min\": 222, \"x_max\": 408, \"y\": null}, {\"slot_index\": 1, \"x_min\": 408, \"x_max\": 568, \"y\": null}, {\"slot_index\": 2, \"x_min\": 568, \"x_max\": 728, \"y\": null}, {\"slot_index\": 3, \"x_min\": 728, \"x_max\": 900, \"y\": null}, {\"slot_index\": 4, \"x_min\": 900, \"x_max\": 1066, \"y\": null}, {\"slot_index\": 5, \"x_min\": 1066, \"x_max\": 1230, \"y\": null}, {\"slot_index\": 6, \"x_min\": 1230, \"x_max\": 1390, \"y\": null}, {\"slot_index\": 7, \"x_min\": 1390, \"x_max\": 1576, \"y\": null}]}\n]"
    
    if os.path.isfile(arquivo_mapas) and os.access(arquivo_mapas, os.R_OK):
    
        with open(arquivo_mapas, encoding="utf8") as map_data_text:
            return json.load(map_data_text)
    
    else:
        
        with open(arquivo_mapas, "w") as f:
            f.write(json_mapas)
            
    
    return json.loads(json_mapas)


def Atualizar_Cash(client_session):
    if client_session is not None:
        client_session.send_encrypted(0x1032, Converter_INT_para_BYTES(client_session.user.cash, 4))


def Mensagem_Para_o_Jogo(client_session, in_message):
    if client_session is not None:
        client_session.send(0x5101, in_message.encode("ascii"))
 



def Atualizar_Sala(client_session):
    if client_session is not None:
        client_session.send(0x3105, bytes.fromhex(""), rtc=0)


def Criar_Uma_Sala(self, received_data, client_session, address, titulo):
    print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> CRIOU UMA SALA")
    #received_data = data[6:]
    print(str(received_data))
    room_title = Decodificar_STRING(received_data[1:received_data[0] + 1])
    if titulo != 0:
        room_title = titulo
    # [0:3] game configuration - see 3101, [4:7] pass, [8] room capacity
    room_other_data = received_data[received_data[0] + 1:]
    room_playmode = Converter_BYTES_para_INT(room_other_data[2:4], 2)
    room_playmode_string = "DESCONHECIDO"
    if room_playmode == 0:
        room_playmode_string = "SOLO"
    elif room_playmode == 0x44:
        room_playmode_string = "SCORE"
    elif room_playmode == 0x08:
        room_playmode_string = "TAG"
    elif room_playmode == 0x0C:
        room_playmode_string = "JEWEL"
    room_password = Decodificar_STRING(room_other_data[4:8])
    room_capacity = room_other_data[8]
    created_room = Sala(Encontrar_Posicao_Da_Sala(self.world_room), room_title, room_password, 0, room_other_data[0:4], room_capacity)
    client_session.room_slot = 0  # host room slot
    client_session.is_room_key = True  # indicates host
    client_session.room_tank_primary = 0xFF
    client_session.room_tank_secondary = 0xFF
    created_room.player_sessions.append(client_session)
    self.world_room.append(created_room)
    print("SERVIDOR DO JOGO: " + str(address) + " Criando sala", room_title, "com senha", room_password, "jogando", room_playmode_string, "para", room_capacity, "jogadores.")
    room_join_reply = bytearray()
    room_join_reply.extend(bytes.fromhex("00 00 00"))  # unknown
    room_join_reply.extend(Converter_INT_para_BYTES(created_room.room_id, 2))
    room_join_reply.extend(self.motd_room.encode("ascii"))
    client_session.send(0x2121, room_join_reply)
    
    for session_item in self.world_session:
        if session_item.client is not None:
            if client_session.user is not None and session_item.user is not None:
                if client_session.user.username != session_item.user.username:
                    Mensagem_Para_o_Jogo(session_item, client_session.user.username + " criou a sala: " + room_title + ", de numero: " + str(created_room.room_id))


def Entrar_Em_Uma_Sala(self, data, client_session, address, requested_room_id, requested_room_password):
	requested_room: Sala = Encontrar_Sala_Por_ID(self.world_room, requested_room_id)
	if requested_room is None:
		print("SERVIDOR DO JOGO: " + str(address) + " Solicitou uma sala invalida.")
		Mensagem_Para_o_Jogo(client_session, "A sala nao existe, atualizando lista de salas...")
		Carregar_Salas(self, client_session, data, address);
	else:
		client_session.room_team = Encontrar_Equipe_Na_Sala(requested_room)
		client_session.room_slot = Encontrar_Espaco_Na_Sala(requested_room)
		client_session.room_tank_primary = 0xFF
		client_session.room_tank_secondary = 0xFF
		requested_room.player_sessions.append(client_session)
		client_ip = Converter_IP_para_BYTES(client_session.address[0])
		client_port = bytes.fromhex("20 AB")  # 8363 seems to be hardcoded
		print("SERVIDOR DO JOGO: " + str(address) + " " + client_session.user.username, " - ", requested_room_id, requested_room_password)
		client_session.send(0x21F5, bytes.fromhex("03"), rtc=0)  # unknown - why 3?
		client_join_request = bytearray()
		client_join_request.extend(Converter_INT_para_BYTES(0, 2))  # probably RTC but not sure
		client_join_request.extend(Converter_INT_para_BYTES(0x0100, 2))  # unknown
		client_join_request.extend(Converter_INT_para_BYTES(requested_room.room_id, 2))  # probably room id
		client_join_request.append(len(requested_room.room_name))
		client_join_request.extend(requested_room.room_name.encode("ascii"))
		client_join_request.append(requested_room.map_id)
		client_join_request.extend(requested_room.game_settings)
		client_join_request.extend(bytes.fromhex("FF FF FF FF FF FF FF FF"))  # 4x WORDs?
		client_join_request.append(requested_room.occupants_max)
		client_join_request.append(len(requested_room.player_sessions))
		for session_item in requested_room.player_sessions:
			session_ip = Converter_IP_para_BYTES(session_item.address[0])
			client_join_request.append(session_item.room_slot)
			client_join_request.extend(Redimensionar_BYTES(session_item.user.username.encode("ascii"), 0xC))
			client_join_request.extend(session_ip)
			client_join_request.extend(client_port)
			client_join_request.extend(session_ip)
			client_join_request.extend(client_port)
			client_join_request.append(session_item.room_tank_primary)  # primary tank
			client_join_request.append(session_item.room_tank_secondary)  # secondary tank
			client_join_request.append(session_item.room_team)  # team side (0 = A, 1 = B)
			client_join_request.append(0x01)  # unknown, stays at 1
			client_join_request.extend(session_item.user.avatar_equipped)  # currently worn avatar
			client_join_request.extend(Redimensionar_BYTES(session_item.user.guild.encode("ascii"), 8))
			client_join_request.extend(Converter_INT_para_BYTES(session_item.user.rank_current, 2))
			client_join_request.extend(Converter_INT_para_BYTES(session_item.user.rank_season, 2))
		client_join_request.extend(self.motd_room.encode("ascii"))
		client_session.send(0x2111, client_join_request)
		for session_item in requested_room.player_sessions:
			if session_item.is_room_key:
				print("SERVIDOR DO JOGO: " + str(address) + " Enviando solicitacao de associacao ao host da sala", session_item.user.username)
				join_request = bytearray()
				join_request.append(client_session.room_slot)
				join_request.extend(Redimensionar_BYTES(client_session.user.username.encode("ascii"), 0xC))
				join_request.extend(client_ip)
				join_request.extend(client_port)
				join_request.extend(client_ip)
				join_request.extend(client_port)
				join_request.append(client_session.room_tank_primary)  # primary tank
				join_request.append(client_session.room_tank_secondary)  # secondary tank
				join_request.append(client_session.room_team)  # team side
				join_request.extend(client_session.user.avatar_equipped)  # currently worn avatar
				join_request.extend(Redimensionar_BYTES(client_session.user.guild.encode("ascii"), 8))
				join_request.extend(Converter_INT_para_BYTES(client_session.user.rank_current, 2))
				join_request.extend(Converter_INT_para_BYTES(client_session.user.rank_season, 2))
				session_item.send(0x3010, join_request)



def Entrar_Em_Um_Canal(self, data, client_session, motd_channel, address):
    if client_session.room_slot != -1:
        print("SERVIDOR DO JOGO: " + str(address) + " Limpeza do SALA solicitada")
        previous_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
        new_keybearer_session: Sessao = None
        for session_item in previous_room.player_sessions:
            if session_item.user.username != client_session.user.username:
                new_keybearer_session = session_item
                break

        migration_packet = bytearray()
        if new_keybearer_session is not None:
            migration_packet.append(new_keybearer_session.room_slot)
            migration_packet.append(len(previous_room.room_name))
            migration_packet.extend(previous_room.room_name.encode("ascii"))
            migration_packet.append(previous_room.map_id)
            migration_packet.extend(previous_room.game_settings)
            migration_packet.extend(bytes.fromhex("FF FF FF FF FF FF FF FF"))  # unknown
            migration_packet.append(previous_room.occupants_max)  # guessed

        for session_item in previous_room.player_sessions:
            if session_item.user.username != client_session.user.username:
                print("SERVIDOR DO JOGO: " + str(address) + " Enviando pacote de migracao")
                session_item.send(0x3020, Converter_INT_para_BYTES(client_session.room_slot, 2))
                session_item.send(0x3400, migration_packet)

        if Remover_Sessao(self.world_room, client_session.user.username):
            Remover_Salas_Vazias(self.world_room)
            print("SERVIDOR DO JOGO: " + str(address) + " Limpeza da sala concluida com sucesso")
        else:
            print("SERVIDOR DO JOGO: " + str(address) + " Limpeza da sala solicitada, mas falhou")

        client_session.room_slot = -1
        client_session.is_room_key = False

    desired_channel = Converter_BYTES_para_INT(data[-2:], 2)
    if desired_channel == 0xFFFF:
        print("SERVIDOR DO JOGO: " + str(address) + " Novo login, roteamento para o canal 1", hex(desired_channel))
        desired_channel = 0
    extended_channel_motd = motd_channel + "\r\n" + "Hora Atual: " + datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")

    active_channel_users = []
    for session_item in self.world_session:
        if session_item.room_slot == -1:
            active_channel_users.append(session_item)

    channel_join_packet_new = bytearray()
    channel_join_packet_new.extend(bytes.fromhex("00 00"))
    channel_join_packet_new.extend(Converter_INT_para_BYTES(desired_channel, 2))
    channel_join_packet_new.append(find_highest_channel_position(active_channel_users))
    channel_join_packet_new.append(len(active_channel_users))

    for session_item in active_channel_users:
        channel_player = bytearray()
        channel_player.append(session_item.channel_position)
        channel_player.extend(Redimensionar_BYTES(session_item.user.username.encode("ascii"), 12))
        channel_player.extend(session_item.user.avatar_equipped)  # gender determined from avatar?
        channel_player.extend(Redimensionar_BYTES(session_item.user.guild.encode("ascii"), 8))
        channel_player.extend(Converter_INT_para_BYTES(session_item.user.rank_current, 2))
        channel_player.extend(Converter_INT_para_BYTES(session_item.user.rank_season, 2))
        channel_join_packet_new.extend(channel_player)

    channel_join_packet_new.extend(extended_channel_motd.encode("ascii"))

    client_session.send(0x2001, channel_join_packet_new)

    join_notification = bytearray()
    join_notification.append(client_session.channel_position)
    join_notification.extend(Redimensionar_BYTES(client_session.user.username.encode("ascii"), 0xC))
    join_notification.extend(client_session.user.avatar_equipped)  # avatar
    join_notification.extend(Redimensionar_BYTES(client_session.user.guild.encode("ascii"), 8))
    join_notification.extend(Converter_INT_para_BYTES(client_session.user.rank_current, 2))  # current rank
    join_notification.extend(Converter_INT_para_BYTES(client_session.user.rank_season, 2))  # season rank

    for session_item in active_channel_users:
        if session_item.user.username != client_session.user.username:
            session_item.send(0x200E, join_notification)


def Iniciar_Jogo(self, data, client_session, address):
    unknown_data = data[6:]  # A2 89 CB 01 / seems different every time, longer for multiplayer
    selected_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
    selected_room.room_state = 1  # waiting -> playing
    start_data = bytearray()

    if selected_room.map_id == 0:
        print("SERVIDOR DO JOGO: " + str(address) + " Rolando mapa aleatorio com", self.parent_instance.cave_map_chance_percentage, "%")
        if random.randint(0, 100) <= self.parent_instance.cave_map_chance_percentage:
            selected_room.map_id = 0  # special map (cave), assigning it for readability
        else:
            selected_room.map_id = random.randint(1, 10)
        start_data.append(selected_room.map_id)  # random, normal map
    else:
        start_data.append(selected_room.map_id)  # user-selected map

    current_map_data = None
    spawn_points = []  # can be overwritten in the future to support Mix / EvsW
    for map_row in self.parent_instance.map_data:
        if map_row["map_id"] == selected_room.map_id:
            current_map_data = map_row
            map_side_ab = selected_room.game_settings[2] & 1
            print("SERVIDOR DO JOGO: " + str(address) + " Lado do mapa (A=0, B=1):", map_side_ab)
            if map_side_ab == 0:
                spawn_points = current_map_data["positions_a_side"]
            else:
                spawn_points = current_map_data["positions_b_side"]

    spawn_order = list(range(8))
    random.shuffle(spawn_order)
    print("SERVIDOR DO JOGO: " + str(address) + " Ordem de criacao/slot:", spawn_order)

    turn_order = list(range(len(selected_room.player_sessions)))
    random.shuffle(turn_order)
    print("SERVIDOR DO JOGO: " + str(address) + " Ordem de turno/slot:", turn_order)

    start_data.extend(Converter_INT_para_BYTES(len(selected_room.player_sessions), 2))
    for session_item in selected_room.player_sessions:
        if session_item.room_tank_primary == 0xFF:
            print("SERVIDOR DO JOGO: " + str(address) + " Rolando primario aleatorio com", self.parent_instance.special_bot_chance_percentage, "%")
            if random.randint(0, 100) <= self.parent_instance.special_bot_chance_percentage:
                session_item.room_tank_primary = random.randint(17, 18)
            else:
                session_item.room_tank_primary = random.randint(0, 13)
        if session_item.room_tank_secondary == 0xFF:
            print("SERVIDOR DO JOGO: " + str(address) + " Rolando secundario aleatorio com", self.parent_instance.special_bot_chance_percentage, "%")
            if random.randint(0, 100) <= self.parent_instance.special_bot_chance_percentage:
                session_item.room_tank_secondary = random.randint(17, 18)
            else:
                session_item.room_tank_secondary = random.randint(0, 13)

        start_data.append(session_item.room_slot)
        start_data.extend(Redimensionar_BYTES(session_item.user.username.encode("ascii"), 0xC))
        start_data.append(session_item.room_team)
        start_data.append(session_item.room_tank_primary)
        start_data.append(session_item.room_tank_secondary)
        player_spawn_point = spawn_points[spawn_order[session_item.room_slot]]  # default randomized spawn
        player_x = random.randint(player_spawn_point["x_min"], player_spawn_point["x_max"])
        player_y = 0 if player_spawn_point["y"] is None else player_spawn_point["y"]
        print("SERVIDOR DO JOGO: " + str(address) + " Ponto de reproducao do jogador:", player_spawn_point, "x:", player_x, "y", player_y)
        start_data.extend(Converter_INT_para_BYTES(player_x, 2))  # x position
        start_data.extend(Converter_INT_para_BYTES(player_y, 2))  # y position

        start_data.extend(Converter_INT_para_BYTES(turn_order[session_item.room_slot], 2))  # turn position. thanks @phnx
    start_data.extend(bytes.fromhex("00 FF"))
    start_data.extend(unknown_data)  # echo the stuff sent by game host

    for session_item in selected_room.player_sessions:
        session_item.send_encrypted(0x3432, start_data)



def Gerar_Pacote_Sessao(sent_packet_length, command, data_bytes):
	packet_expected_length = len(data_bytes) + 6
	packet_sequence = Gerar_Sequencia(sent_packet_length + packet_expected_length)

	response = bytearray()
	response.extend(Converter_INT_para_BYTES(packet_expected_length, 2))
	response.extend(Converter_INT_para_BYTES(packet_sequence, 2))
	response.extend(Converter_INT_para_BYTES(command, 2))

	response.extend(data_bytes)
	return response


def get_session(in_world_session, in_username):
	for session_item in in_world_session:
		if session_item.user.username == in_username:
			return session_item
	return None


def Remover_Sessao2(in_world_session, in_username):
	for index in range(len(in_world_session)):
		if in_world_session[index].user.username == in_username:
			in_world_session.pop(index)


def find_channel_position(in_world_session):
	for index in range(0xFF):
		index_is_occupied = False
		for session_item in in_world_session:
			if session_item.channel_position == index:
				index_is_occupied = True
				break
		if not index_is_occupied:
			return index
	print("Nenhum slot de canal disponivel")
	return 0


def find_highest_channel_position(in_world_session):
	highest_position = 0
	for session_item in in_world_session:
		if session_item.channel_position > highest_position:
			highest_position = session_item.channel_position
	return highest_position


def sendall(in_world_session, in_command, in_data):
	for session_item in in_world_session:
		session_item.send(in_command, in_data)


def Gerar_Pacote(sent_packet_length, command, data_bytes):
    packet_expected_length = len(data_bytes) + 6
    packet_sequence = Gerar_Sequencia(sent_packet_length + packet_expected_length)

    if sent_packet_length == -1:
        packet_sequence = 0xCBEB

    response = bytearray()
    response.extend(Converter_INT_para_BYTES2(packet_expected_length, 2))
    response.extend(Converter_INT_para_BYTES2(packet_sequence, 2))
    response.extend(Converter_INT_para_BYTES2(command, 2))

    response.extend(data_bytes)
    return response

def Gerar_Servidor_Individual(entry, position):
    extended_description = entry.server_description + "\r\n[" + str(entry.server_utilization) + "/" + str(entry.server_capacity) + "] Jogadores Online"
    response = bytearray()
    response.extend([position, 0x00, 0x00])
    response.append(len(entry.server_name))
    response.extend(entry.server_name.encode("ascii"))
    response.append(len(extended_description))
    response.extend(extended_description.encode("ascii"))
    response.extend(map(int, entry.server_address.split('.')))
    response.extend(Converter_INT_para_BYTES2(entry.server_port, 2, big_endian=True))
    response.extend(Converter_INT_para_BYTES2(entry.server_utilization, 2,  big_endian=True))
    response.extend(Converter_INT_para_BYTES2(entry.server_utilization, 2,  big_endian=True))
    response.extend(Converter_INT_para_BYTES2(entry.server_capacity, 2,  big_endian=True))
    response.append(int(entry.server_enabled))
    return response


def Adicionar_Bots_No_Canal(self):
    
    virtual_bots = []
    with open("Temporarios\Bots.txt") as data_text:
        data = json.load(data_text)
        random.shuffle(data)
        for json_row in data:
            virtual_bots.append(json_row["id"])
    
    sala_1 = Sala(0, "Entra ai!!!", "", 0, bytes.fromhex("B2620C00"), 4)
    self.world_room.append(sala_1)

    
    sala_de_bots = Sala(randint(1, 100), "Sala dos Bots", "", 1, bytes.fromhex("B2620C00"), 4)
    
    contaBots = 0;
    for virtual_bot in virtual_bots:
        virtual_session = Sessao(None, None)
        virtual_session.user = Encontrar_Usuario_Por_Nome(self.world_user, virtual_bot)
        virtual_session.user.guild = "BOT"
        virtual_session.channel_position = find_channel_position(self.world_session)
        
        if contaBots < 10:
            if contaBots < 4:
                sala_de_bots.player_sessions.append(virtual_session)
            else:
                self.world_session.append(virtual_session)
        
        contaBots += 1;
        
    self.world_room.append(sala_de_bots)




def Carregar_Salas(self, client_session, data, address):
    room_filter_mode = data[6]
    if room_filter_mode == 1:
        print("SERVIDOR DO JOGO: " + str(address) + " Buscando Salas, Filtro: TODOS")
    elif room_filter_mode == 2:
        print("SERVIDOR DO JOGO: " + str(address) + " Buscando Salas, Filtro: AGUARDANDO")
    else:
        print("SERVIDOR DO JOGO: " + str(address) + " Buscando Salas, Filtro: DESCONHECIDO")

    room_reply = bytearray()
    room_reply.extend(Converter_INT_para_BYTES(len(self.world_room), 2))

    for room_item in self.world_room:
        room_entry = bytearray()
        room_entry.extend(Converter_INT_para_BYTES(room_item.room_id, 2))  # 0-indexed room number, as WORD
        room_entry.append(len(room_item.room_name))
        room_entry.extend(room_item.room_name.encode("ascii"))
        room_entry.append(room_item.map_id)  # map: 0 = random, 1 = miramo ..
        room_entry.extend(room_item.game_settings)  # example bytes: B2620C00
        room_entry.append(len(room_item.player_sessions))  # occupant count
        room_entry.append(room_item.occupants_max)  # max occupants
        room_entry.append(room_item.room_state)  # play state or ready (play = 1, waiting = 0)
        if len(room_item.password) > 0:
            room_entry.append(1)  # room locked: 1 = password required
        else:
            room_entry.append(0)  # room locked: 0 = default open
        room_reply.extend(room_entry)

    client_session.send(0x2103, room_reply, rtc=0)




class Restricao_De_Funcoes:
    AVATAR_ENABLED: int = 1 << 4
    EFFECT_FORCE: int = 1 << 13
    EFFECT_TORNADO: int = 1 << 14
    EFFECT_LIGHTNING: int = 1 << 15
    EFFECT_WIND: int = 1 << 16
    EFFECT_THOR: int = 1 << 17
    EFFECT_MOON: int = 1 << 18
    EFFECT_ECLIPSE: int = 1 << 19
    EVENT1_ENABLE: int = 1 << 20
    EVENT2_ENABLE: int = 1 << 21
    EVENT3_ENABLE: int = 1 << 22
    EVENT4_ENABLE: int = 1 << 23



class Sala:
    room_id: int = -1
    room_name = ""
    password = ""
    map_id = 0
    game_settings = bytes.fromhex("00 00 00 00")
    occupants_max = 0
    room_state = 0  # waiting: 0, play: 1
    player_sessions = []

    def __init__(self, in_id, in_room_name, in_password, in_map_id, in_game_settings, in_occupants_max):
        self.room_id = in_id
        self.room_name = in_room_name
        self.password = in_password
        self.map_id = in_map_id
        self.game_settings = in_game_settings
        self.occupants_max = in_occupants_max
        self.player_sessions = []



class Usuario:
    username = ""
    password = ""
    guild = ""
    rank_current = 10
    rank_season = 10
    cash: int = 9999999
    gold: int = 9999999
    avatar_equipped = bytes.fromhex("00 80 00 80 00 80 00 00")
    avatar_inventory = []

    def __init__(self, in_username, in_guild, in_rank_current):
        self.username = in_username
        self.password = in_username
        self.guild = in_guild
        self.rank_current = in_rank_current
        self.rank_season = in_rank_current
        self.avatar_equipped = bytes.fromhex("00 80 00 80 00 80 00 00")
        self.avatar_inventory = []



class Sessao:
    auth_token = bytearray()
    session_unique = bytearray()
    user: Usuario = None
    channel_position = -1
    client_version = 0
    socket_tx_sum = 0
    client = None
    address = None

    is_room_key = False
    room_slot = -1
    room_team = 0
    room_tank_primary = 0xFF
    room_tank_secondary = 0xFF

    def __init__(self, client_socket, in_address):
        self.auth_token = secrets.token_bytes(4)
        self.session_unique = secrets.token_bytes(4)
        self.client = client_socket
        self.address = in_address
        self.room_slot = -1
        self.is_room_key = False
        if self.client is not None:
            print("SERVIDOR DO JOGO: " + str(in_address) + " Nova sessao inicializada")
            print("SERVIDOR DO JOGO: " + str(in_address) + " IP da sessao: " + str(self.address[0]) + ", Porta: " + str(self.address[1]))

    def decrypt(self, encrypted_bytes, client_command):
        return gunbound_dynamic_decrypt(encrypted_bytes, self.user.username, self.user.password, self.auth_token, client_command)

    def encrypt(self, plain_bytes, client_command):
        mutable_plain_bytes = bytearray()
        mutable_plain_bytes.extend(plain_bytes)
        for unused_pad_byte in range(12 - (len(plain_bytes) % 12)):
            mutable_plain_bytes.append(0x00)

        return gunbound_dynamic_encrypt(mutable_plain_bytes, self.user.username, self.user.password, self.auth_token, client_command)

    def send(self, command, bytes_to_send, rtc=None):
        payload = None
        if rtc is None:
            payload = Gerar_Pacote_Sessao(self.socket_tx_sum, command, bytes_to_send)
        else:
            mutable_bytes_to_send = bytearray()
            mutable_bytes_to_send.extend(Converter_INT_para_BYTES(rtc, 2))
            mutable_bytes_to_send.extend(bytes_to_send)
            payload = Gerar_Pacote_Sessao(self.socket_tx_sum, command, mutable_bytes_to_send)
        if self.client is None:
            return
        self.client.send(payload)
        self.socket_tx_sum += len(payload)

    def send_encrypted(self, command, bytes_to_send, rtc=None):
        self.send(command, self.encrypt(bytes_to_send, command), rtc=rtc)


class GameUDPServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind((self.host, self.port))


    def listen(self):
        while True:
            udp_payload, udp_client_address = self.sock.recvfrom(1024)
            print("UDP: " + str(udp_client_address) + " Ecoando dados de volta para " + str(udp_client_address), Converter_BYTES_para_HEX(udp_payload))
            self.sock.sendto(udp_payload, udp_client_address)
            print("UDP: " + str(udp_client_address) + " UDP Concluido")


class CommandProcessor:
    world_session = []
    world_room = []
    parent_instance = None

    def __init__(self, in_world_session, in_world_room, in_parent_instance):
        self.world_session = in_world_session
        self.world_room = in_world_room
        self.parent_instance = in_parent_instance


class ServerOption:
    def __init__(self, server_name: str, server_description: str, server_address: str, server_port: int, server_utilization: int, server_capacity: int, server_enabled: bool):
        self.server_name = server_name
        self.server_description = server_description
        self.server_address = server_address
        self.server_port = server_port
        self.server_utilization = server_utilization
        self.server_capacity = server_capacity
        self.server_enabled = server_enabled


class ListaDeServidores(object):
    server_options = []
    world_session = []

    def __init__(self, host, port, in_options, in_world_session):
        self.host = host
        self.port = port
        self.server_options = in_options
        self.world_session = in_world_session
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind((self.host, self.port))

    def listen(self):
        self.sock.listen(5)
        print("LISTA DE SERVIDORES: AGUARDANDO LOGS DA PORTA:", self.port)
        while True:
            client, address = self.sock.accept()
            threading.Thread(target = self.Conexao_Do_Usuario, args=(client, address)).start()

    def Conexao_Do_Usuario(self, client, address):
        print("LISTA DE SERVIDORES: " + str(address) + " Nova conexao")
        socket_rx_size = 1024
        socket_rx_sum = 0
        while True:
            try:
                data = client.recv(socket_rx_size)
                if data:
                    if len(data) < 6:
                        print("LISTA DE SERVIDORES: " + str(address) + " Pacote invalido, comprimento: " + len(data))
                        print(data)
                    else:
                        payload_size = (data[1] << 8) | data[0]
                        client_command = (data[5] << 8) | data[4]
                        socket_rx_sum += payload_size
                        if client_command == 0x1013:
                            print("LISTA DE SERVIDORES: " + str(address) + " Solicitacao de autenticacao")
                            login_packet = Gerar_Pacote(-1, 0x1312, Converter_INT_para_BYTES2(0x0000, 2, big_endian=True))
                            client.send(login_packet)
                        elif client_command == 0x1100:
                            print("LISTA DE SERVIDORES: " + str(address) + " Solicitacao de diretorio do servidor")
                            directory_packet = bytearray()
                            directory_packet.extend([0x00, 0x00, 0x01])  # unknown
                            directory_packet.append(len(self.server_options))
                            for i in range(len(self.server_options)):
                                self.server_options[i].server_utilization = len(self.world_session)
                                directory_packet.extend(Gerar_Servidor_Individual(self.server_options[i], i))
                            directory_packet = Gerar_Pacote(0, 0x1102, directory_packet)
                            client.send(directory_packet)
                else:
                
                    print("LISTA DE SERVIDORES: " + str(address) + " Cliente desconectado")
                    return True
                    
            except Exception as e:
            
                print("ERRO LISTA DE SERVIDORES: (" + str(address) + ") (" + str(e) + ")")




class Servidor_Do_Jogo(object):
    host = None
    port = 0
    motd_channel = "Digite /help para ver todos os comandos de admin.\n\n------------------------------------------------------------\nFeito Por Thalles Tutoriais\nCanal no Youtube: Youtube.com/VideosTutoriais\nBaixe seu proprio servidor de GunboundTH em thalles.net/gb\n------------------------------------------------------------\n"
    motd_room = "Digite /help para ver todos os comandos de admin.\nDigite o comando /jogar ou /start para iniciar um jogo forcado.\n\n------------------------------------------------------------\nFeito Por Thalles Tutoriais\nCanal no Youtube: Youtube.com/VideosTutoriais\nBaixe seu proprio servidor de GunboundTH em thalles.net/gb\n------------------------------------------------------------\n"
    special_bot_chance_percentage = 50  # normally 2% (2)
    cave_map_chance_percentage = 20  # normally 20% (20)
    map_data = []
    gs_funcrestrict = 0xFFFFF
    world_session = []
    world_room = []
    world_user = []
    
    command_processor: CommandProcessor = None

    def __init__(self, host, port, in_world_session, in_world_room, in_world_user):
        self.host = host
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind((self.host, self.port))

        self.world_session = in_world_session
        self.world_room = in_world_room
        self.world_user = in_world_user

        self.map_data = Carregar_Informacoes_Do_Mapa()
        udp_server = GameUDPServer(host, port)
        threading.Thread(target = udp_server.listen).start()

        self.command_processor = CommandProcessor(self.world_session, self.world_room, self)
        Adicionar_Bots_No_Canal(self)

    def listen(self):
        self.sock.listen(5)
        print("SERVIDOR DO JOGO: AGUARDANDO LOGS DA PORTA:", self.port)
        while True:
            client, address = self.sock.accept()
            threading.Thread(target = self.Conexao_Do_Usuario, args = (client, address)).start()


    def Conexao_Do_Usuario(self, client, address):
        print("SERVIDOR DO JOGO: " + str(address) + " Nova conexao")
        
        socket_rx_size = 1024
        client_session = Sessao(client, address)
        socket_rx_sum = 0

        while True:
            try:
            
                data = client.recv(socket_rx_size)
                
                
                if data:
                    if len(data) < 6:
                        
                        print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO BROKEN PACKET>>")
                        print("SERVIDOR DO JOGO: " + str(address) + " " + Converter_BYTES_para_HEX(data))
                    
                    else:
                        
                        payload_size = Converter_BYTES_para_INT(data[0: 2], 2)
                        client_command = Converter_BYTES_para_INT(data[4:6], 2)
                        socket_rx_sum += payload_size
                        
                        if client_command == 0x1000:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " Token gerado:", Converter_BYTES_para_HEX(client_session.auth_token))
                            client_session.send(0x1001, client_session.auth_token)
                        
                        elif client_command == 0x0000:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> KEEPALIVE")
                    
                            for session_item in self.world_session:
                                if session_item.client is not None:
                                    if client_session.user is not None and session_item.user is not None:
                                        if client_session.user.username != session_item.user.username:
                                            Mensagem_Para_o_Jogo(session_item, client_session.user.username + " saiu no Gunbound por inatividade!")

                        
                        elif client_command == 0x1010:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_LOGIN/ADMIN")
                            username_bytes = gunbound_static_decrypt(data[6:6 + 0x10])
                            queried_user = Encontrar_Usuario_Por_Nome(self.world_user, Decodificar_STRING(username_bytes))
                            if queried_user is None:
                                print("SERVIDOR DO JOGO: " + str(address) + " O nome de usuario nao existe, criando uma nova conta...")
                                self.world_user = Carregar_Usuarios(Decodificar_STRING(username_bytes))
                                Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                                username_bytes = gunbound_static_decrypt(data[6:6 + 0x10])
                                queried_user = Encontrar_Usuario_Por_Nome(self.world_user, Decodificar_STRING(username_bytes))
                                client_session.user = queried_user
                                
                                for session_item in self.world_session:
                                    if session_item.client is not None:
                                        if client_session.user is not None and session_item.user is not None:
                                            if client_session.user.username != session_item.user.username:
                                                Mensagem_Para_o_Jogo(session_item, client_session.user.username + " acabou de criar conta no Gunbound!")

                            
                            client_session.user = queried_user
                            dynamic_payload = client_session.decrypt(data[6 + 0x20:], client_command)
                            print("SERVIDOR DO JOGO: " + str(address) + " Nome do usuario:", client_session.user.username)
                            client_session.client_version = dynamic_payload[0x14] | (dynamic_payload[0x15] << 8)
                            client_session.channel_position = find_channel_position(self.world_session)
                            self.world_session.append(client_session)
                            login_packet = bytearray()
                            login_packet.extend(bytearray.fromhex("00 00"))  # maybe gender?
                            login_packet.extend(client_session.session_unique)  # "seems unused
                            login_packet.extend(Redimensionar_BYTES(client_session.user.username.encode("ascii"), 0xC))
                            login_packet.extend(client_session.user.avatar_equipped)  # currently worn avatar
                            login_packet.extend(Redimensionar_BYTES(client_session.user.guild.encode("ascii"), 8))
                            login_packet.extend(Converter_INT_para_BYTES(client_session.user.rank_current, 2))
                            login_packet.extend(Converter_INT_para_BYTES(client_session.user.rank_season, 2))
                            login_packet.extend(Converter_INT_para_BYTES(5, 2))  # guild member count
                            login_packet.extend(Converter_INT_para_BYTES(1, 2))  # rank position, current
                            login_packet.extend(Converter_INT_para_BYTES(0, 2))  # ?
                            login_packet.extend(Converter_INT_para_BYTES(1, 2))  # rank position, season
                            login_packet.extend(Converter_INT_para_BYTES(0, 2))  # ?
                            login_packet.extend(Converter_INT_para_BYTES(1, 2))  # individual's guild rank
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 0000"))
                            login_packet.extend(Converter_INT_para_BYTES(1, 4))  # gp, current
                            login_packet.extend(Converter_INT_para_BYTES(1, 4))  # gp, season
                            login_packet.extend(Converter_INT_para_BYTES(client_session.user.gold, 4))  # gold
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.append(0)  # still unknown
                            login_packet.extend(Converter_INT_para_BYTES(self.gs_funcrestrict, 4))  # weather, event etc
                            client_session.send(0x1012, login_packet)
                            Atualizar_Cash(client_session)
                            
                            for session_item in self.world_session:
                                if session_item.client is not None:
                                    if client_session.user is not None and session_item.user is not None:
                                        if client_session.user.username != session_item.user.username:
                                            Mensagem_Para_o_Jogo(session_item, client_session.user.username + " entrou no Gunbound!")
                        
                        elif client_command == 0x1020:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_USER_ID")
                            payload_data = client_session.decrypt(data[6:], 0x1020)
                            requested_username = Decodificar_STRING(payload_data[0:0xC])
                            found_id = Encontrar_Usuario_Por_Nome(self.world_user, requested_username)
                            print("SERVIDOR DO JOGO: " + str(address) + " Consultando para", requested_username)
                            if found_id is None:
                                print("SERVIDOR DO JOGO: " + str(address) + " Nenhum usuario encontrado:", requested_username)
                            else:
                                print("SERVIDOR DO JOGO: " + str(address) + " ID encontrado:", found_id.username)
                                id_crypted_response = bytearray()
                                id_crypted_response.extend(Redimensionar_BYTES(found_id.username.encode("ascii"), 0xC))
                                id_crypted_response.extend(Redimensionar_BYTES(found_id.username.encode("ascii"), 0xC))
                                id_crypted_response.extend(Redimensionar_BYTES(found_id.guild.encode("ascii"), 8))
                                id_crypted_response.extend(Converter_INT_para_BYTES(found_id.rank_current, 2))
                                id_crypted_response.extend(Converter_INT_para_BYTES(found_id.rank_season, 2))
                                client_session.send_encrypted(0x1021, id_crypted_response, rtc=0)
                                Carregar_Salas(self, client_session, data, address);
                        
                        elif client_command == 0x2000:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> ENTROU EM UM CANAL")
                            Entrar_Em_Um_Canal(self.command_processor, data, client_session, self.motd_channel, address)
                            print("SERVIDOR DO JOGO: " + str(address) + " NOVOS USUARIOS CARREGADOS")
                            world_user = Carregar_Usuarios(0)
                            Carregar_Salas(self, client_session, data, address)
                        
                        elif client_command == 0x2100:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SOLICITANDO SALAS")
                            Carregar_Salas(self, client_session, data, address);
                        
                        elif client_command == 0x2104:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> DETALHE DA SALA")
                            requested_room_id = Converter_BYTES_para_INT(data[6:], 2)
                            requested_room = Sala
                            for room_item in self.world_room:
                                if room_item.room_id == requested_room_id:
                                    requested_room = room_item
                                    print("SERVIDOR DO JOGO: " + str(address) + " Sala encontrada")
                                    break
                            response = bytearray()
                            response.append(len(requested_room.room_name))
                            response.extend(requested_room.room_name.encode("ascii"))
                            response.append(requested_room.map_id)  # map: 0 = random, 1 = miramo ..
                            response.extend(requested_room.game_settings)
                            response.append(len(requested_room.player_sessions))  # occupant count
                            response.append(requested_room.occupants_max)  # max occupants
                            response.append(requested_room.room_state)  # play state
                            if len(requested_room.password) > 0:
                                response.append(1)  # room locked: 1 = password required
                            else:
                                response.append(0)  # room locked: 0 = default open
                            for room_player in requested_room.player_sessions:
                                response.extend(Redimensionar_BYTES(room_player.user.username.encode("ascii"), 0xC))
                                response.extend(room_player.user.avatar_equipped)  # currently worn avatar
                                response.extend(Redimensionar_BYTES(room_player.user.guild.encode("ascii"), 8))
                                response.extend(Converter_INT_para_BYTES(room_player.user.rank_current, 2))
                                response.extend(Converter_INT_para_BYTES(room_player.user.rank_season, 2))
                            client_session.send(0x2105, response, rtc=0)
                            Carregar_Salas(self, client_session, data, address);
                        
                        elif client_command == 0x2110:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> ENTROU NA SALA")
                            requested_room_id = Converter_BYTES_para_INT(data[6:8], 2)
                            requested_room_password = Decodificar_STRING(data[8:])

                            Entrar_Em_Uma_Sala(self, data, client_session, address, requested_room_id, requested_room_password)

                            for session_item in self.world_session:
                                if session_item.client is not None:
                                    if client_session.user is not None and session_item.user is not None:
                                        if client_session.user.username != session_item.user.username:
                                            Mensagem_Para_o_Jogo(session_item, client_session.user.username + " entrou na sala: " + str(requested_room_id))


                        elif client_command == 0x2010:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_CHANNEL_CHAT")
                            dynamic_payload = client_session.decrypt(data[6:], client_command)
                            chat_message = Decodificar_STRING(dynamic_payload[1:dynamic_payload[0] + 1])
                            print("SERVIDOR DO JOGO: " + str(address) + " Canal Chat de", client_session.user.username, ":", chat_message)
                            padded_username = Redimensionar_BYTES(client_session.user.username.encode("ascii"), 0xC)
                            chat_broadcast_packet = bytearray()
                            chat_broadcast_packet.append(client_session.channel_position)  # user's channel position
                            chat_broadcast_packet.extend(padded_username)
                            chat_broadcast_packet.append(len(chat_message))
                            chat_broadcast_packet.extend(chat_message.encode("ascii"))
                            for session_item in self.world_session:
                                session_item.send_encrypted(0x201F, chat_broadcast_packet)
                            Carregar_Salas(self, client_session, data, address);
                        
                        elif client_command == 0x2120:
                            
                            received_data = data[6:]
                            Criar_Uma_Sala(self, received_data, client_session, address, 0)
                            
                        elif client_command == 0x3102:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_CHANGE_USEITEM")
                            prop_state_data = data[6:]
                            prop_state = Converter_BYTES_para_INT(prop_state_data[0:2], 2)
                            print("SERVIDOR DO JOGO: " + str(address) + " Item de uso da sala alterado:", hex(prop_state), bin(prop_state))
                            Atualizar_Sala(client_session)
                        
                        elif client_command == 0x3100:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_CHANGE_STAGE")
                            new_map_id = data[6]  # map 0 = random
                            selected_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.map_id = new_map_id
                                print("SERVIDOR DO JOGO: " + str(address) + " ID do sala:", selected_room.room_id, "mapa definido como", new_map_id)
                            else:
                                print("SERVIDOR DO JOGO: " + str(address) + " A sala selecionada e Nenhum - ignorando")
                            Atualizar_Sala(client_session)
                        
                        elif client_command == 0x3101:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_CHANGE_OPTION")
                            map_properties = data[6:]
                            selected_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.game_settings = map_properties
                            Atualizar_Sala(client_session)
                        
                        elif client_command == 0x3104:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SET_ROOM_TITLE")
                            new_title_raw = data[6:]
                            new_title_string = Decodificar_STRING(new_title_raw)
                            print("SERVIDOR DO JOGO: " + str(address) + " SET_ROOM_TITLE", new_title_string)
                            selected_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.room_name = new_title_string
                            Atualizar_Sala(client_session)
                        
                        elif client_command == 0x3103:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_CHANGE_MAXMEN")
                            room_capacity = data[6]  # map 0 = random
                            selected_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.occupants_max = room_capacity
                                print(selected_room.room_id, "nova capacidade da sala:", room_capacity)
                            Atualizar_Sala(client_session)
                        
                        elif client_command == 0x3210:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> MUDOU DE TIME")
                            new_team_position = data[6]
                            print("SERVIDOR DO JOGO: " + str(address) + " Mudando de equipe para", new_team_position)
                            client_session.room_team = new_team_position
                            client_session.send(0x3211, bytes.fromhex(""), rtc=0)
                        
                        elif client_command == 0x3200:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> MUDOU DE MOBILE")
                            mobile_string = {0: "Armor",
                                             1: "Mage",
                                             2: "Nak",
                                             3: "Trico",
                                             4: "Bigfoot",
                                             5: "Boomer",
                                             6: "Raon",
                                             7: "Lightning",
                                             8: "J.D.",
                                             9: "A.Sate",
                                             10: "Ice",
                                             11: "Turtle",
                                             12: "Grub",
                                             13: "Aduka",
                                             17: "Dragon",  # technically 14 (from disassembly), actually 17 (phnx)
                                             18: "Knight",  # technically 15, actually 18 (phnx).
                                             255: "Random"}
                            tank_primary = data[6]
                            tank_secondary = data[7]
                            client_session.room_tank_primary = tank_primary
                            client_session.room_tank_secondary = tank_secondary
                            print("SERVIDOR DO JOGO: " + str(address) + " " + client_session.user.username, "selecionado", tank_primary, tank_secondary)
                            client_session.send(0x3201, bytes.fromhex(""), rtc=0)
                        
                        elif client_command == 0x3230:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_USER_READY")
                            ready_state = data[6]
                            print("SERVIDOR DO JOGO: " + str(address) + " SVC_ROOM_USER_READY", ready_state)
                            client_session.send(0x3231, bytes.fromhex(""), rtc=0)
                        
                        elif client_command == 0x3232:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_ROOM_RETURN_RESULT")
                            client_room = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            if client_room is not None:
                                client_room.room_state = 0  # switch room state back to "waiting"
                            client_session.send(0x3233, bytes.fromhex(""), rtc=0)
                        
                        elif client_command == 0x3430:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_START_GAME")
                            Iniciar_Jogo(self.command_processor, data, client_session, address)
                        
                        elif client_command == 0x4200:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PLAY_END_JEWEL")
                            Mensagem_Para_o_Jogo(client_session, "Parabens, chegou a 100 pontos!")
                            Mensagem_Para_o_Jogo(client_session, "Escreva o comando /sair para sair da sala.")
                            #message_to_rebroadcast = client_session.decrypt(data[6:], 0x4200)
                            #client_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            #for session_item in client_room.player_sessions:
                            #    session_item.send_encrypted(0x4410, message_to_rebroadcast)
                        
                        elif client_command == 0x4100:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PLAY_USER_DEAD")
                            client_session.send(0x4101, bytes.fromhex(""))  # reply to origin
                        
                        elif client_command == 0x4412:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PLAY_RESULT")
                            client_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                            for session_item in client_room.player_sessions:
                                session_item.send(0x4413, bytes.fromhex(""))
                        
                        elif client_command == 0x4500:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_TUNNEL")
                            tunnel_bytes = data[6:]
                            requester_id = tunnel_bytes[0xC: 0x18]
                            destination_id = tunnel_bytes[0x18: 0x24]
                            print("SERVIDOR DO JOGO: " + str(address) + " Tunel solicitado:", Decodificar_STRING(requester_id), "para", Decodificar_STRING(destination_id))
                        
                        elif client_command == 0x6000:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_GET")
                            flag_send_extended = data[6]
                            user_extended_avatar = client_session.user.avatar_inventory
                            prop_reply = bytearray()
                            prop_reply.extend(client_session.user.avatar_equipped)  # 8 bytes of equipped "short" avatar
                            prop_reply.extend(Converter_INT_para_BYTES(client_session.user.gold, 4))  # user's gold as DWORD
                            if flag_send_extended == 1:
                                prop_reply.extend(Converter_INT_para_BYTES(len(user_extended_avatar), 2))  # avatar count as WORD
                                for avatar_item in user_extended_avatar:
                                    prop_reply.extend(avatar_item)  # add "long" avatar codes (DWORDs)
                            client_session.send_encrypted(0x6001, prop_reply, rtc=0)
                            Atualizar_Cash(client_session)
                        
                        elif client_command == 0x6004:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_SET")
                            plain_avatar_equipped = client_session.decrypt(data[6:], 0x6004)
                            avatar_equipped = plain_avatar_equipped[0:8]  # 8 bytes of equipped avatar
                            client_session.user.avatar_equipped = bytes(avatar_equipped)
                            print("SERVIDOR DO JOGO: " + str(address) + " " + client_session.user.username, "equipando", Converter_BYTES_para_HEX(bytes(avatar_equipped)))
                            client_session.send(0x6005, bytes.fromhex(""), rtc=0)
                            Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                        
                        elif client_command == 0x6011:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_BUY_PP")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6011)
                            extended_avatar = plain_bought_avatar[0:4]  # DWORD avatar
                            print(client_session.user.username, "bought (cash)", Converter_BYTES_para_HEX(bytes(extended_avatar)))
                            client_session.user.avatar_inventory.append(extended_avatar)
                            client_session.send(0x6017, bytes.fromhex(""), rtc=0)
                            Atualizar_Cash(client_session)
                            Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                        
                        elif client_command == 0x6010:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_BUY")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6010)
                            extended_avatar = plain_bought_avatar[0:4]  # DWORD avatar
                            print(client_session.user.username, "comprado (ouro)", Converter_BYTES_para_HEX(bytes(extended_avatar)))
                            client_session.user.avatar_inventory.append(extended_avatar)
                            client_session.send(0x6017, bytes.fromhex(""), rtc=0)
                            Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                        
                        elif client_command == 0x6020:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_SELL")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6020)
                            extended_avatar = plain_bought_avatar[1:5]  # DWORD avatar
                            print(client_session.user.username, "vendido", Converter_BYTES_para_HEX(bytes(extended_avatar)))
                            client_session.send(0x6027, bytes.fromhex(""), rtc=0)
                            Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                        
                        elif client_command == 0x6030:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> SVC_PROP_GIFT")
                            gift_plain_packet = client_session.decrypt(data[6:], 0x6030)
                            gift_recipient = Decodificar_STRING(gift_plain_packet[0:0xC])
                            extended_avatar = gift_plain_packet[0x11:0x15]  # DWORD avatar
                            gift_message = Redimensionar_BYTES(gift_plain_packet[0x16:], gift_plain_packet[0x15])
                            gift_message = Decodificar_STRING(gift_message)
                            print(client_session.user.username, "presenteou", Converter_BYTES_para_HEX(bytes(extended_avatar)), "para",
                                  gift_recipient, "com a mensagem:", gift_message)
                            client_session.send(0x6037, bytes.fromhex(""), rtc=0x6005)
                            Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                        
                        elif client_command == 0x5100:
                            
                            print("SERVIDOR DO JOGO: " + str(address) + " RECEBIDO> COMANDO GENERICO")
                            Carregar_Salas(self, client_session, data, address)
                            command_received_raw = Decodificar_STRING(data[7:]).split(" ")
                            command_received = command_received_raw.pop(0).lower()
                            command_parameters = " ".join(command_received_raw)
                            print("SERVIDOR DO JOGO: " + str(address) + " COMANDO RECEBIDO> " + str(command_received))
                            if command_received == "vem":
                                
                                print("SERVIDOR DO JOGO: " + str(address) + " Solicitou que todos entrem na sala: " + str(command_parameters))
                                
                                for session_item in self.world_session:
                                    if session_item.client is not None:
                                        if client_session.user is not None and session_item.user is not None:
                                            if client_session.user.username != session_item.user.username:
                                                Entrar_Em_Uma_Sala(self, data, session_item, address, int(command_parameters), "")
                                    
                            elif command_received == "sala":
                                
                                print("SERVIDOR DO JOGO: " + str(address) + " Criou uma nova sala: " + str(command_parameters))
                                received_data = b'\x011\xb2b\x00\x00\x00\x00\x00\x00\x08'
                                Criar_Uma_Sala(self, received_data, client_session, address, command_parameters)
                                
                            
                            elif command_received == "start" or command_received == "jogar" or command_received == "comecar":
                                
                                client_room = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                                if client_room is not None:
                                    print("SERVIDOR DO JOGO: " + str(address) + " Jogo iniciado com o comando /" + command_received)
                                    Iniciar_Jogo(self.command_processor, data, client_session, address)
                                else:
                                    Mensagem_Para_o_Jogo(client_session, "Voce precisa entrar em uma sala para usar o comando /" + command_received)
                                    print("SERVIDOR DO JOGO: " + str(address) + " O jogador precisa entrar em uma sala para usar o comando /" + command_received)


      
                            
                            elif command_received == "mobile":
                                
                                tank_value = int(command_parameters)
                                client_session.room_tank_primary = tank_value
                                response_message = "Seu tanque principal sera definido como " + str(tank_value) + "\nIsso entra em vigor apos entrar em uma sala"
                                Mensagem_Para_o_Jogo(client_session, response_message)
                            
                            elif command_received == "rank":
                                
                                rank_value = int(command_parameters)
                                client_session.user.rank_current = rank_value
                                response_message = "Os numero de rank validos são de -4 a 20\nE necessario fazer login novamente para que as alteracoes entrem em vigor"
                                Mensagem_Para_o_Jogo(client_session, response_message)
                            
                            elif command_received == "guild" or command_received == "cla" or command_received == "clan":
                                
                                client_session.user.guild = command_parameters
                                response_message = "O cla foi alterado para " + command_parameters + "\nE necessario fazer login novamente para que as alteracoes entrem em vigor"
                                Mensagem_Para_o_Jogo(client_session, str(client_session.user.guild))
                            
                            elif command_received == "genero" or command_received == "avatar":
                                
                                if command_parameters == "f":
                                    avatar_random = Gerar_Avatar_Random(command_parameters)
                                else:
                                    avatar_random = Gerar_Avatar_Random("m")
                                client_session.user.avatar_equipped = bytes.fromhex("" + avatar_random[8:12] + "" + avatar_random[0:4] + "" + avatar_random[16:20] + "" + avatar_random[24:28] + "")
                                client_session.user.avatar_inventory = [bytes.fromhex(avatar_random[0:8]),bytes.fromhex(avatar_random[8:16]),bytes.fromhex(avatar_random[16:24]),bytes.fromhex(avatar_random[24:32])]
                                response_message = "E necessario fazer login novamente para que as alteracoes entrem em vigor"
                                Mensagem_Para_o_Jogo(client_session, response_message)
                            
                            elif command_received == "msg" or command_received == "mensagem" or command_received == "aviso":
                                
                                for session_item in self.world_session:
                                    Mensagem_Para_o_Jogo(session_item, command_parameters)
                            
                            elif command_received == "conexao":
                            
                                client_session.send(0x5101, "Conexao ainda ativa".encode("ascii"))
                            
                            elif command_received == "online":
                            
                                for session_item in self.world_session:
                                    if session_item.client is not None:
                                        message_row = session_item.user.username + ": " + session_item.address[0]
                                        Mensagem_Para_o_Jogo(client_session, message_row)
                            
                            elif command_received == "salvar":
                            
                                Mensagem_Para_o_Jogo(client_session, "Salvando - verifique o console python.")
                                Salvar_Modificacoes_Dos_Usuarios(self.world_user, address)
                                Mensagem_Para_o_Jogo(client_session, "Configuracoes salvas")
                            
                            elif command_received == "fechar":
                            
                                client_room: Sala = Encontrar_Sala_Por_Usuario(self.world_room, client_session.user.username)
                                if client_room is not None:
                                    for room_player in client_room.player_sessions:
                                        room_player.send(0x3FFF, bytes.fromhex(""))
                                        Mensagem_Para_o_Jogo(room_player, "Sala fechada")
                            
                            elif command_received == "sair":
                            
                                client_session.send(0x3FFF, bytes.fromhex(""))
                                Mensagem_Para_o_Jogo(client_session, "Sala fechada")
                            
                            else:
                                
                                Mensagem_Para_o_Jogo(client_session, "O comando nao existe!")
                        
                        
                        else:
                            
                            Mensagem_Para_o_Jogo(client_session, client_command)
                            print("SERVIDOR DO JOGO: " + str(address) + " Resposta desconhecida ao comando do cliente:", client_command)

                
                else:
                
                    for session_item in self.world_session:
                        if session_item.client is not None:
                            if client_session.user is not None and session_item.user is not None:
                                if client_session.user.username != session_item.user.username:
                                    Mensagem_Para_o_Jogo(session_item, client_session.user.username + " saiu no Gunbound!")


                    print("SERVIDOR DO JOGO: " + str(address) + " Cliente desconectado")
                    if client_session is not None:
                        if client_session.channel_position != -1:
                            for session_item in self.world_session:
                                if session_item.user.username != client_session.user.username:
                                    user_channel = bytearray()
                                    user_channel.append(client_session.channel_position)
                                    session_item.send(0x200F, user_channel)
                        if client_session.room_slot != -1:
                            Remover_Sessao(self.world_room, client_session.user.username)
                            Remover_Salas_Vazias(self.world_room)
                        
                        if client_session.user is not None:
                            print("SERVIDOR DO JOGO: " + str(address) + " " + str(client_session.user.username) + " desconectado")
                            Remover_Sessao2(self.world_session, client_session.user.username)
                        else:
                            print("SERVIDOR DO JOGO: " + str(address) + " Nenhum ID encontrado, cliente desconectado")
                    
                    return True
            
            except Exception as e:
                
                
                print("ERRO SERVIDOR DO JOGO: " + str(address) + " (" + str(e) + ")")

                
                for session_item in self.world_session:
                    if session_item.client is not None:
                        Carregar_Salas(self, session_item, data, address)
                        Mensagem_Para_o_Jogo(session_item, "\n\n------------------------------------------------------------\nErro no servidor, erro ignorado para nao fechar o jogo.\nErro causado por: " + str(address) + "\n------------------------------------------------------------\n" + str(e) + "\n------------------------------------------------------------\n\n")


if __name__ == "__main__":

    if path.exists('Temporarios') == False:
        os.mkdir("Temporarios")

    ip = Gerar_Endereco_De_IP()
    ip_tipo = Gerar_Tipo_De_IP()

    print("==============================================================================")
    print("SERVIDOR DE GUNBOUND LIGADO! IP: " + ip + "")
    print("==============================================================================")
    if ip_tipo == "FIXO":
        print("O IP Fixo do seu Servidor de Gunbound e: " + ip + "")
        print("Os jogadores devem acessar http://" + ip + "/ para baixar o jogo.")
        print("LEMBRE-SE: De abrir as portas 80, 8370 e 8372 do seu Modem.")
        print("Voce tambem deve desativar o Firewall do PC do servidor.")
    else:
        print("O IP Local do seu Servidor de Gunbound e: " + ip + "")
        print("Os jogadores devem acessar http://" + ip + "/ para baixar o jogo.")
        print("LEMBRE-SE: Se quiser jogar Online com seus amigos")
        print("Todos os jogadores devem estar na mesma rede Wifi que o servidor.")
        print("Voce tambem deve desativar o Firewall do PC do servidor.")
    print("==============================================================================")
    print("\n")

    requisitos = "Requisitos.txt";
    with open(requisitos, "w") as f:
        f.write("altgraph==0.16.1\nfuture==0.17.1\nmacholib==1.11\npefile==2018.8.8\nPyInstaller==3.4\npywin32-ctypes==0.2.0")

    world_session = []
    world_room = []
    world_user = Carregar_Usuarios(0)
    lista_de_servidores = []
    bind_address = "0.0.0.0"
    enabled_server_functions = [
    Restricao_De_Funcoes.AVATAR_ENABLED,
    Restricao_De_Funcoes.EFFECT_FORCE,
    Restricao_De_Funcoes.EFFECT_TORNADO,
    Restricao_De_Funcoes.EFFECT_LIGHTNING,
    Restricao_De_Funcoes.EFFECT_WIND,
    Restricao_De_Funcoes.EFFECT_THOR,
    Restricao_De_Funcoes.EFFECT_MOON,
    Restricao_De_Funcoes.EFFECT_ECLIPSE
    #Restricao_De_Funcoes.EVENT1_ENABLE,
    #Restricao_De_Funcoes.EVENT2_ENABLE,
    #Restricao_De_Funcoes.EVENT3_ENABLE,
    #Restricao_De_Funcoes.EVENT4_ENABLE
    ]


    lista_de_servidores = Carregar_Lista_De_Servidores()

    broker_server = ListaDeServidores(bind_address, 8372, lista_de_servidores, world_session)
    threading.Thread(target = broker_server.listen).start()

    enabled_server_functions = [Restricao_De_Funcoes.EFFECT_THOR, Restricao_De_Funcoes.EFFECT_FORCE, Restricao_De_Funcoes.EFFECT_MOON, Restricao_De_Funcoes.EFFECT_LIGHTNING, Restricao_De_Funcoes.AVATAR_ENABLED]

    server: Servidor_Do_Jogo = Servidor_Do_Jogo(bind_address, 8370, world_session, world_room, world_user)
    server.gs_funcrestrict = Gerar_Valor_Da_Funcao(enabled_server_functions)
    threading.Thread(target = server.listen).start()
