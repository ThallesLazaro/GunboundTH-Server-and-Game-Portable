import socket
import threading
import secrets
import random
import PY_ServidorGB_Criptografia
import datetime
import json
from random import seed
from random import randint

# TODO:
# Tunnel - firewall test pc to force tunnel, figure out whats going on
# Figure out positional data. right now everyone's spawned on the same spot
# closing of rooms, handling people leaving the room
# clean the 518 client to make it "as stock as possible"
# make data persistent - flat-file or peewee
# fix dragon, knight issue

# FIXME:
# update client when player leaves channel to enter a game
# above bug probably causes a rejoin to fail
# more than 6 rooms: pagination
# room is orphaned if host leaves
# key handover announces wrong slot
# when joining a room, primary/secondary bot should be random 0xFF


def gerar_avatar_random(genero):
    chapelMASCULINO = ["01800100", "02800100", "03800100", "04800100", "05800100", "06800100", "07800100", "08800100", "09800100", "0A800100", "0B800100", "0D800100", "0E800100", "0F800100", "10800100", "11800100", "12800100", "13800100", "14800100", "15800100", "16800100", "17800100", "18800100", "19800100", "1A800100", "1B800100", "1C800100", "1D800100", "1E800100", "1F800100", "20800100", "21800100", "22800100", "23800100", "24800100", "25800100", "26800100", "27800100", "28800100", "29800100", "2A800100", "2B800100", "2C800100", "2D800100", "2E800100", "2F800100", "30800100", "31800100", "32800100", "33800100", "34800100", "35800100", "36800100", "37800100", "38800100", "39800100", "3A800100", "3B800100", "3C800100", "3D800100", "3E800100", "3F800100", "40800100", "41800100", "42800100", "43800100", "44800100", "45800100", "46800100", "47800100", "48800100", "49800100", "4A800100", "4B800100", "4C800100", "4D800100", "4E800100", "4F800100", "50800100", "51800100", "52800100", "53800100", "54800100", "55800100", "56800100", "57800100", "58800100", "59800100", "5A800100", "5B800100", "5C800100", "5D800100", "5E800100", "5F800100", "60800100", "61800100", "62800100", "63800100", "64800100", "65800100", "68800100", "69800100", "6A800100", "6B800100", "6D800100", "6E800100", "6F800100", "70800100", "71800100", "72800100", "73800100", "74800100", "75800100", "76800100", "77800100", "78800100", "7A800100", "7B800100", "7C800100", "7D800100", "7E800100", "7F800100", "80800100", "81800100", "82800100", "83800100", "84800100", "85800100", "86800100", "87800100", "88800100", "89800100", "8A800100", "8B800100", "8C800100", "8E800100", "8F800100", "90800100", "91800100", "92800100", "95800100", "96800100", "97800100", "98800100", "99800100", "9A800100", "9B800100", "9C800100", "9D800100", "9E800100", "9F800100", "A0800100", "A1800100", "A2800100", "A3800100", "A4800100", "A5800100", "A6800100", "A7800100", "A8800100", "A9800100", "AA800100", "AB800100", "AC800100", "AD800100", "AE800100", "B0800100", "B1800100", "B2800100", "B3800100", "B4800100", "B5800100", "B6800100", "B7800100", "B8800100", "B9800100", "C3800100", "C5800100", "C6800100", "C7800100", "CC800100", "CD800100", "D2800100", "D3800100", "D8800100", "D9800100", "DA800100", "DB800100", "DC800100", "DE800100", "E8800100", "E9800100", "EC800100", "ED800100", "EE800100", "EF800100", "F0800100", "F6800100", "F7800100", "F8800100", "FB800100", "FC800100", "FD800100", "00810100", "03810100", "04810100", "05810100", "06810100", "07810100", "08810100", "09810100", "0A810100", "0B810100", "0D810100", "0F810100", "10810100", "11810100", "12810100", "13810100", "14810100", "15810100", "16810100", "17810100", "18810100", "19810100", "1A810100", "1B810100", "1C810100", "1E810100", "1F810100", "22810100", "23810100", "24810100", "25810100", "26810100", "27810100", "28810100", "29810100", "2A810100", "2B810100", "2C810100", "2D810100", "2E810100", "2F810100", "30810100", "34810100", "35810100", "36810100", "37810100", "38810100", "39810100", "3A810100", "3B810100", "3C810100", "3D810100", "3E810100", "3F810100", "40810100", "41810100", "42810100", "43810100", "44810100", "70810100", "71810100", "72810100", "73810100", "74810100", "75810100", "76810100", "77810100", "78810100", "79810100", "7A810100", "7B810100", "7C810100", "7D810100", "7E810100", "7F810100", "80810100", "81810100", "82810100", "83810100", "84810100", "85810100", "86810100", "87810100", "88810100", "89810100", "8A810100", "8A810100", "8B810100", "8C810100", "8D810100", "8E810100", "8F810100", "90810100", "91810100", "92810100", "93810100", "94810100", "95810100", "96810100", "97810100", "98810100", "99810100", "9A810100", "9B810100", "9C810100", "9D810100", "9E810100", "9F810100", "A0810100", "A1810100", "A2810100", "A3810100", "A4810100", "A5810100", "A6810100", "A7810100", "A8810100", "A9810100", "AA810100", "AB810100", "AC810100", "AD810100", "AE810100", "AF810100", "B0810100", "B1810100", "B2810100", "B3810100", "B4810100", "B5810100", "B6810100", "B7810100", "B8810100", "B9810100", "BA810100", "BB810100", "BC810100", "BD810100", "BE810100", "BF810100", "C0810100", "C1810100", "C2810100", "C3810100", "C4810100", "C5810100", "C6810100", "C7810100", "C8810100", "C9810100", "CA810100", "CB810100", "CC810100", "F2810100", "F3810100", "F4810100", "F5810100", "F6810100", "F7810100", "F8810100", "F9810100", "FA810100", "FB810100", "FC810100", "FD810100", "FE810100", "FF810100", "00820100", "01820100", "03820100", "04820100", "05820100", "06820100", "07820100", "08820100", "09820100", "0A820100", "0B820100", "0C820100", "0D820100", "0E820100", "0F820100", "10820100", "11820100", "12820100", "13820100", "14820100", "15820100", "16820100", "56820100", "57820100", "58820100", "59820100", "5A820100", "5B820100", "5C820100", "5D820100", "5E820100", "5F820100", "60820100", "61820100", "62820100", "63820100", "64820100", "65820100", "66820100", "67820100", "68820100", "69820100", "6A820100", "6B820100", "6D820100", "6E820100", "71820100", "7A820100", "7B820100", "7C820100", "7D820100", "7E820100", "7F820100", "80820100", "81820100", "82820100", "83820100", "84820100", "85820100", "86820100", "87820100", "88820100", "89820100", "8A820100", "8B820100", "8C820100", "8D820100", "8E820100", "8F820100", "90820100", "91820100", "92820100", "93820100", "94820100", "96820100", "98820100", "99820100", "9A820100", "9B820100", "9C820100", "9D820100", "9E820100", "9F820100", "A0820100", "A1820100", "A2820100", "A3820100", "A4820100", "A5820100", "A7820100", "A8820100", "A9820100", "AA820100", "AB820100", "AC820100", "AE820100", "AF820100", "B0820100", "B1820100", "B2820100", "B3820100", "B4820100", "B5820100", "B6820100", "B7820100", "B8820100", "B9820100", "CF820100"];
    roupaMASCULINO = ["01800000", "02800000", "03800000", "04800000", "05800000", "06800000", "07800000", "08800000", "09800000", "0A800000", "0B800000", "0C800000", "0D800000", "0E800000", "0F800000", "10800000", "11800000", "12800000", "13800000", "14800000", "15800000", "16800000", "17800000", "18800000", "19800000", "1A800000", "1B800000", "1C800000", "1D800000", "1E800000", "1F800000", "20800000", "21800000", "22800000", "23800000", "24800000", "25800000", "26800000", "27800000", "28800000", "29800000", "2A800000", "2B800000", "2C800000", "2D800000", "2E800000", "2F800000", "30800000", "31800000", "32800000", "33800000", "34800000", "35800000", "36800000", "37800000", "38800000", "39800000", "3A800000", "3B800000", "3C800000", "3D800000", "3E800000", "3F800000", "40800000", "41800000", "42800000", "43800000", "44800000", "45800000", "46800000", "47800000", "48800000", "49800000", "4A800000", "4B800000", "4C800000", "4D800000", "4E800000", "4F800000", "50800000", "51800000", "52800000", "53800000", "54800000", "55800000", "56800000", "57800000", "58800000", "59800000", "5A800000", "5B800000", "5C800000", "5D800000", "5E800000", "5F800000", "60800000", "61800000", "62800000", "63800000", "6D800000", "6E800000", "6F800000", "70800000", "71800000", "72800000", "73800000", "74800000", "75800000", "76800000", "77800000", "78800000", "79800000", "7A800000", "7B800000", "7C800000", "7D800000", "7E800000", "7F800000", "80800000", "81800000", "82800000", "83800000", "84800000", "85800000", "86800000", "87800000", "88800000", "89800000", "8A800000", "8B800000", "8C800000", "8E800000", "8F800000", "90800000", "91800000", "92800000", "94800000", "95800000", "96800000", "97800000", "98800000", "99800000", "9A800000", "9B800000", "9C800000", "9D800000", "9E800000", "9F800000", "A0800000", "A1800000", "A2800000", "A3800000", "A4800000", "A5800000", "A6800000", "A7800000", "A8800000", "A9800000", "AA800000", "B2800000", "B3800000", "B4800000", "B5800000", "B8800000", "B9800000", "C4800000", "C6800000", "C7800000", "CC800000", "CD800000", "D2800000", "D3800000", "D8800000", "D9800000", "DA800000", "DB800000", "DC800000", "DE800000", "E8800000", "E9800000", "EC800000", "ED800000", "EE800000", "EF800000", "F0800000", "F6800000", "F7800000", "F8800000", "FB800000", "FC800000", "FD800000", "00810000", "03810000", "04810000", "05810000", "06810000", "07810000", "08810000", "09810000", "0A810000", "0B810000", "0D810000", "0F810000", "10810000", "11810000", "12810000", "13810000", "14810000", "15810000", "16810000", "17810000", "18810000", "19810000", "1A810000", "1B810000", "1C810000", "1E810000", "1F810000", "22810000", "23810000", "24810000", "25810000", "26810000", "27810000", "28810000", "29810000", "2A810000", "2B810000", "2C810000", "2D810000", "2E810000", "2F810000", "30810000", "32810000", "33810000", "34810000", "35810000", "36810000", "37810000", "38810000", "39810000", "3A810000", "3B810000", "3C810000", "3D810000", "3E810000", "3F810000", "40810000", "41810000", "42810000", "43810000", "44810000", "70810000", "71810000", "72810000", "73810000", "74810000", "75810000", "76810000", "77810000", "78810000", "79810000", "7A810000", "7B810000", "7C810000", "7D810000", "7E810000", "7F810000", "80810000", "81810000", "82810000", "83810000", "84810000", "85810000", "86810000", "87810000", "88810000", "89810000", "8A810000", "8B810000", "8C810000", "8D810000", "8E810000", "8F810000", "90810000", "91810000", "92810000", "93810000", "94810000", "95810000", "96810000", "97810000", "98810000", "99810000", "9A810000", "9B810000", "9C810000", "9D810000", "9E810000", "9F810000", "A0810000", "A1810000", "A2810000", "A3810000", "A4810000", "A5810000", "A6810000", "A7810000", "A8810000", "A9810000", "AA810000", "AB810000", "AC810000", "AD810000", "AE810000", "AF810000", "B0810000", "B1810000", "B2810000", "B3810000", "B4810000", "B5810000", "B6810000", "B7810000", "B8810000", "B9810000", "BA810000", "BB810000", "BC810000", "BD810000", "BE810000", "BF810000", "C0810000", "C1810000", "C2810000", "C3810000", "C4810000", "C5810000", "C6810000", "C7810000", "C8810000", "C9810000", "CA810000", "CB810000", "CC810000", "F2810000", "F3810000", "F4810000", "F5810000", "F6810000", "F7810000", "F8810000", "F9810000", "FA810000", "FB810000", "FC810000", "FD810000", "FE810000", "FF810000", "00820000", "01820000", "03820000", "04820000", "05820000", "06820000", "07820000", "08820000", "09820000", "0A820000", "0B820000", "0C820000", "0D820000", "0E820000", "0F820000", "10820000", "11820000", "12820000", "13820000", "14820000", "15820000", "16820000", "56820000", "57820000", "58820000", "59820000", "5A820000", "5B820000", "5C820000", "5D820000", "5E820000", "5F820000", "60820000", "61820000", "62820000", "63820000", "64820000", "65820000", "66820000", "67820000", "68820000", "69820000", "6A820000", "6B820000", "6D820000", "6E820000", "71820000", "7A820000", "7B820000", "7C820000", "7D820000", "7E820000", "7F820000", "80820000", "81820000", "82820000", "83820000", "84820000", "85820000", "86820000", "87820000", "88820000", "89820000", "8A820000", "8B820000", "8C820000", "8D820000", "8E820000", "8F820000", "90820000", "91820000", "92820000", "93820000", "94820000", "96820000", "98820000", "99820000", "9A820000", "9B820000", "9C820000", "9D820000", "9E820000", "9F820000", "A0820000", "A1820000", "A2820000", "A3820000", "A4820000", "A5820000", "A7820000", "A8820000", "A9820000", "AA820000", "AB820000", "AC820000", "AE820000", "AF820000", "B0820000", "B1820000", "B2820000", "B3820000", "B4820000", "B5820000", "B6820000", "B7820000", "B8820000", "B9820000", "CF820000"];
    oculosMASCULINO = ["01800200", "02800200", "03800200", "04800200", "05800200", "06800200", "07800200", "08800200", "09800200", "0A800200", "0B800200", "0C800200", "0D800200", "0E800200", "0F800200", "10800200", "11800200", "12800200", "14800200", "15800200", "16800200", "17800200", "18800200", "19800200", "1A800200", "1B800200", "1C800200", "1D800200", "1E800200", "1F800200", "20800200", "21800200", "22800200", "23800200", "24800200", "25800200", "26800200", "27800200", "28800200", "2A800200", "2B800200", "2C800200", "2D800200", "2E800200", "2F800200", "30800200", "31800200", "32800200", "33800200", "34800200", "35800200", "36800200", "37800200", "38800200", "39800200", "3A800200", "3B800200", "3C800200", "3D800200", "3F800200", "41800200", "47800200", "48800200", "4D800200", "4E800200", "4F800200", "50800200", "56800200", "57800200", "58800200", "59800200", "5B800200", "5D800200", "5F800200", "60800200", "62800200", "66800200", "67800200", "69800200", "6A800200", "6B800200", "6F800200", "70800200", "72800200", "73800200", "76800200", "77800200", "78800200", "7B800200", "7C800200", "7D800200", "7E800200", "7F800200", "80800200", "81800200", "82800200", "83800200", "85800200", "86800200", "87800200", "88800200", "89800200", "8A800200", "8B800200", "8C800200", "8D800200", "8E800200", "8F800200", "90800200", "91800200", "92800200", "93800200", "94800200", "95800200", "96800200", "97800200", "98800200", "99800200", "9A800200", "9B800200", "9C800200", "9D800200", "9E800200", "9F800200", "A0800200", "A1800200", "A2800200", "A3800200", "A4800200", "A6800200", "A7800200", "A8800200", "A9800200", "AA800200", "AB800200", "AC800200", "AD800200", "AE800200", "AF800200", "B0800200", "B1800200", "B2800200", "B3800200", "B4800200", "B5800200", "B6800200", "B7800200", "B8800200", "B9800200", "BA800200", "18810200", "19810200", "1A810200", "1C810200", "1D810200", "1E810200", "1F810200", "20810200", "21810200", "23810200", "24810200", "26810200", "27810200", "28810200", "29810200", "2A810200", "2C810200", "2D810200"];
    chapelFEMININO = ["01000100", "02000100", "03000100", "04000100", "05000100", "06000100", "07000100", "08000100", "09000100", "0A000100", "0B000100", "0C000100", "0E000100", "0F000100", "10000100", "11000100", "12000100", "13000100", "14000100", "15000100", "16000100", "17000100", "18000100", "19000100", "1A000100", "1B000100", "1C000100", "1D000100", "1E000100", "1F000100", "20000100", "21000100", "22000100", "23000100", "24000100", "25000100", "26000100", "27000100", "28000100", "29000100", "2A000100", "2B000100", "2C000100", "2D000100", "2E000100", "2F000100", "30000100", "31000100", "32000100", "33000100", "34000100", "35000100", "36000100", "37000100", "38000100", "39000100", "3A000100", "3B000100", "3C000100", "3D000100", "3E000100", "3F000100", "40000100", "41000100", "42000100", "43000100", "44000100", "45000100", "46000100", "47000100", "48000100", "49000100", "4A000100", "4B000100", "4C000100", "4D000100", "4E000100", "4F000100", "50000100", "51000100", "52000100", "53000100", "54000100", "55000100", "56000100", "57000100", "58000100", "59000100", "5A000100", "5B000100", "5C000100", "5D000100", "5E000100", "60000100", "61000100", "62000100", "63000100", "64000100", "65000100", "66000100", "67000100", "68000100", "69000100", "6A000100", "6B000100", "6C000100", "6D000100", "6E000100", "6F000100", "71000100", "72000100", "73000100", "74000100", "75000100", "76000100", "77000100", "78000100", "7B000100", "7C000100", "7E000100", "7F000100", "80000100", "81000100", "82000100", "83000100", "84000100", "85000100", "86000100", "87000100", "88000100", "89000100", "8A000100", "8B000100", "8C000100", "8D000100", "8E000100", "8F000100", "90000100", "92000100", "93000100", "94000100", "95000100", "96000100", "99000100", "9A000100", "9B000100", "9C000100", "9D000100", "9E000100", "9F000100", "A0000100", "A1000100", "A2000100", "A3000100", "A4000100", "A5000100", "A6000100", "A7000100", "A8000100", "A9000100", "AA000100", "AC000100", "AD000100", "AE000100", "AF000100", "B0000100", "B1000100", "B2000100", "B3000100", "B4000100", "B5000100", "B6000100", "B7000100", "B8000100", "B9000100", "BA000100", "BB000100", "BC000100", "BD000100", "BE000100", "C4000100", "C6000100", "C7000100", "C8000100", "CD000100", "CE000100", "D3000100", "D4000100", "D9000100", "DA000100", "DB000100", "DC000100", "DD000100", "DF000100", "E9000100", "EA000100", "ED000100", "EE000100", "EF000100", "F0000100", "F1000100", "F6000100", "F7000100", "F8000100", "FB000100", "FC000100", "FD000100", "00010100", "03010100", "04010100", "05010100", "06010100", "07010100", "08010100", "09010100", "0A010100", "0B010100", "0C010100", "0E010100", "10010100", "11010100", "12010100", "13010100", "14010100", "15010100", "16010100", "17010100", "18010100", "19010100", "1A010100", "1B010100", "1C010100", "1E010100", "1F010100", "22010100", "23010100", "24010100", "25010100", "26010100", "27010100", "28010100", "29010100", "2A010100", "2B010100", "2C010100", "2D010100", "2E010100", "2F010100", "30010100", "32010100", "33010100", "34010100", "35010100", "36010100", "37010100", "38010100", "39010100", "3A010100", "3C010100", "3D010100", "3E010100", "3F010100", "40010100", "41010100", "42010100", "43010100", "44010100", "70010100", "71010100", "72010100", "73010100", "74010100", "75010100", "76010100", "77010100", "78010100", "79010100", "7A010100", "7B010100", "7C010100", "7D010100", "7E010100", "7F010100", "80010100", "81010100", "82010100", "83010100", "84010100", "85010100", "86010100", "87010100", "88010100", "89010100", "8A010100", "8B010100", "8C010100", "8D010100", "8E010100", "8F010100", "90010100", "91010100", "92010100", "93010100", "94010100", "95010100", "96010100", "97010100", "98010100", "99010100", "9A010100", "9B010100", "9C010100", "9D010100", "9E010100", "9F010100", "A0010100", "A1010100", "A2010100", "A3010100", "A4010100", "A5010100", "A6010100", "A7010100", "A8010100", "A9010100", "AA010100", "AB010100", "AC010100", "AD010100", "AE010100", "AF010100", "B0010100", "B1010100", "B2010100", "B3010100", "B4010100", "B5010100", "B6010100", "B7010100", "B8010100", "B9010100", "BA010100", "BB010100", "BC010100", "BD010100", "BE010100", "BF010100", "C0010100", "C1010100", "C2010100", "C3010100", "C4010100", "C5010100", "C6010100", "C7010100", "C8010100", "C9010100", "CA010100", "CB010100", "CC010100", "F2010100", "F3010100", "F4010100", "F5010100", "F6010100", "F7010100", "F8010100", "F9010100", "FA010100", "FB010100", "FC010100", "FD010100", "FE010100", "FF010100", "00020100", "01020100", "03020100", "04020100", "05020100", "06020100", "07020100", "08020100", "09020100", "0A020100", "0B020100", "0C020100", "0D020100", "0E020100", "0F020100", "10020100", "11020100", "12020100", "13020100", "14020100", "15020100", "16020100", "0E020100", "0F020100", "10020100", "11020100", "12020100", "13020100", "14020100", "15020100", "16020100", "56020100", "57020100", "58020100", "59020100", "5A020100", "5B020100", "5C020100", "5D020100", "5E020100", "5F020100", "60020100", "61020100", "62020100", "63020100", "64020100", "65020100", "66020100", "67020100", "68020100", "69020100", "6A020100", "6B020100", "6D020100", "6E020100", "71020100", "7A020100", "7B020100", "7C020100", "7D020100", "7E020100", "7F020100", "80020100", "81020100", "82020100", "83020100", "84020100", "85020100", "86020100", "87020100", "88020100", "89020100", "8A020100", "8B020100", "8C020100", "8D020100", "8E020100", "8F020100", "90020100", "91020100", "92020100", "93020100", "94020100", "96020100", "98020100", "99020100", "9A020100", "9B020100", "9C020100", "9D020100", "9E020100", "9F020100", "A0020100", "A1020100", "A2020100", "A3020100", "A4020100", "A5020100", "A7020100", "A8020100", "A9020100", "AA020100", "AB020100", "AC020100", "AE020100", "AF020100", "B0020100", "B1020100", "B2020100", "B3020100", "B4020100", "B5020100", "B6020100", "B7020100", "B8020100", "B9020100", "CF020100"];
    roupaFEMININO = ["01000000", "02000000", "03000000", "04000000", "05000000", "06000000", "07000000", "08000000", "09000000", "0A000000", "0B000000", "0C000000", "0D000000", "0E000000", "0F000000", "10000000", "11000000", "12000000", "13000000", "14000000", "15000000", "16000000", "17000000", "18000000", "19000000", "1A000000", "1B000000", "1C000000", "1D000000", "1E000000", "1F000000", "20000000", "21000000", "22000000", "23000000", "24000000", "25000000", "26000000", "27000000", "28000000", "29000000", "2A000000", "2B000000", "2C000000", "2D000000", "2E000000", "2F000000", "30000000", "31000000", "32000000", "33000000", "34000000", "35000000", "36000000", "37000000", "38000000", "39000000", "3A000000", "3B000000", "3C000000", "3D000000", "3E000000", "3F000000", "40000000", "41000000", "42000000", "43000000", "44000000", "45000000", "46000000", "47000000", "48000000", "49000000", "4A000000", "4B000000", "4C000000", "4D000000", "4E000000", "4F000000", "50000000", "51000000", "52000000", "53000000", "54000000", "55000000", "56000000", "57000000", "58000000", "59000000", "5A000000", "5B000000", "5C000000", "5D000000", "5E000000", "5F000000", "60000000", "61000000", "62000000", "63000000", "64000000", "65000000", "66000000", "67000000", "68000000", "69000000", "6A000000", "6B000000", "6D000000", "6E000000", "6F000000", "70000000", "71000000", "72000000", "73000000", "74000000", "75000000", "76000000", "77000000", "78000000", "79000000", "7A000000", "7B000000", "7C000000", "7D000000", "7E000000", "7F000000", "80000000", "81000000", "82000000", "83000000", "84000000", "85000000", "86000000", "87000000", "88000000", "89000000", "8A000000", "8B000000", "8C000000", "8E000000", "90000000", "91000000", "92000000", "94000000", "95000000", "96000000", "97000000", "98000000", "99000000", "9A000000", "9B000000", "9C000000", "9D000000", "9E000000", "9F000000", "A0000000", "A1000000", "A2000000", "A3000000", "A4000000", "A5000000", "A6000000", "A7000000", "A8000000", "A9000000", "AA000000", "AB000000", "AC000000", "AD000000", "AE000000", "B0000000", "B3000000", "B4000000", "BF000000", "C1000000", "C2000000", "C7000000", "C8000000", "CD000000", "CE000000", "D3000000", "D4000000", "D5000000", "D6000000", "D7000000", "D9000000", "E3000000", "E4000000", "E7000000", "E8000000", "E9000000", "EA000000", "EB000000", "F0000000", "F1000000", "F2000000", "F5000000", "F6000000", "F7000000", "FA000000", "FD000000", "FE000000", "FF000000", "00010000", "01010000", "02010000", "03010000", "04010000", "05010000", "06010000", "08010000", "0A010000", "0B010000", "0C010000", "0D010000", "0E010000", "0F010000", "10010000", "11010000", "12010000", "13010000", "1A010000", "1B010000", "1C010000", "1E010000", "1F010000", "22010000", "23010000", "24010000", "25010000", "26010000", "27010000", "28010000", "29010000", "2A010000", "2B010000", "2C010000", "2D010000", "2E010000", "2F010000", "30010000", "32010000", "33010000", "34010000", "35010000", "36010000", "37010000", "38010000", "39010000", "3A010000", "3C010000", "3D010000", "3E010000", "3F010000", "40010000", "41010000", "42010000", "43010000", "44010000", "70010000", "71010000", "72010000", "73010000", "74010000", "75010000", "76010000", "77010000", "78010000", "79010000", "7A010000", "7B010000", "7C010000", "7D010000", "7E010000", "7F010000", "80010000", "81010000", "82010000", "83010000", "84010000", "85010000", "86010000", "87010000", "88010000", "89010000", "8A010000", "8B010000", "8C010000", "8D010000", "8E010000", "8F010000", "90010000", "91010000", "92010000", "93010000", "94010000", "95010000", "96010000", "97010000", "98010000", "99010000", "9A010000", "9B010000", "9C010000", "9D010000", "9E010000", "9F010000", "A0010000", "A1010000", "A2010000", "A3010000", "A4010000", "A5010000", "A6010000", "A7010000", "A8010000", "A9010000", "AA010000", "AB010000", "AC010000", "AD010000", "AE010000", "AF010000", "B0010000", "B1010000", "B2010000", "B3010000", "B4010000", "B5010000", "B6010000", "B7010000", "B8010000", "B9010000", "BA010000", "BB010000", "BC010000", "BD010000", "BE010000", "BF010000", "C0010000", "C1010000", "C2010000", "C3010000", "C4010000", "C5010000", "C6010000", "C7010000", "C8010000", "C9010000", "CA010000", "CB010000", "CC010000", "F2010000", "F3010000", "F4010000", "F5010000", "F6010000", "F7010000", "F8010000", "F9010000", "FA010000", "FB010000", "FC010000", "FD010000", "FE010000", "FF010000", "00020000", "01020000", "03020000", "04020000", "05020000", "06020000", "07020000", "08020000", "09020000", "0A020000", "0B020000", "0C020000", "0D020000", "0E020000", "0F020000", "10020000", "11020000", "12020000", "13020000", "14020000", "15020000", "16020000", "56020000", "57020000", "58020000", "59020000", "5A020000", "5B020000", "5C020000", "5D020000", "5E020000", "5F020000", "60020000", "61020000", "62020000", "63020000", "64020000", "65020000", "66020000", "67020000", "68020000", "69020000", "6A020000", "6B020000", "6D020000", "6E020000", "71020000", "7A020000", "7B020000", "7C020000", "7D020000", "7E020000", "7F020000", "80020000", "81020000", "82020000", "83020000", "84020000", "85020000", "86020000", "87020000", "88020000", "89020000", "8A020000", "8B020000", "8C020000", "8D020000", "8E020000", "8F020000", "90020000", "91020000", "92020000", "93020000", "94020000", "96020000", "98020000", "99020000", "9A020000", "9B020000", "9C020000", "9D020000", "9E020000", "9F020000", "A0020000", "A1020000", "A2020000", "A3020000", "A4020000", "A5020000", "A7020000", "A8020000", "A9020000", "AA020000", "AB020000", "AC020000", "AD020000", "AF020000", "B0020000", "B1020000", "B2020000", "B3020000", "B4020000", "B5020000", "B6020000", "B7020000", "B8020000", "B9020000", "CF020000"];
    oculosFEMININO = ["01000200", "02000200", "03000200", "04000200", "05000200", "06000200", "07000200", "08000200", "09000200", "0A000200", "0B000200", "0C000200", "0D000200", "0E000200", "0F000200", "10000200", "11000200", "12000200", "14000200", "15000200", "16000200", "17000200", "18000200", "19000200", "1A000200", "1B000200", "1C000200", "1D000200", "1E000200", "1F000200", "20000200", "21000200", "22000200", "23000200", "24000200", "25000200", "26000200", "27000200", "28000200", "2A000200", "2B000200", "2C000200", "2D000200", "2E000200", "2F000200", "30000200", "31000200", "32000200", "33000200", "34000200", "35000200", "36000200", "37000200", "38000200", "39000200", "3A000200", "3B000200", "3C000200", "3D000200", "3F000200", "41000200", "42000200", "43000200", "48000200", "49000200", "4E000200", "55000200", "56000200", "57000200", "58000200", "5A000200", "5C000200", "5D000200", "5E000200", "5F000200", "60000200", "61000200", "65000200", "66000200", "68000200", "69000200", "6A000200", "6E000200", "6F000200", "70000200", "72000200", "75000200", "76000200", "77000200", "79000200", "7A000200", "7B000200", "7C000200", "7D000200", "7E000200", "7F000200", "80000200", "81000200", "83000200", "84000200", "85000200", "86000200", "87000200", "88000200", "8B000200", "8C000200", "8D000200", "8E000200", "8F000200", "90000200", "91000200", "92000200", "93000200", "94000200", "95000200", "96000200", "97000200", "98000200", "99000200", "9A000200", "9B000200", "9C000200", "9D000200", "9E000200", "9F000200", "A0000200", "A1000200", "A2000200", "A3000200", "A4000200", "A5000200", "A6000200", "A7000200", "A8000200", "A9000200", "AA000200", "AB000200", "AC000200", "AD000200", "AE000200", "AF000200", "B0000200", "B1000200", "B2000200", "B3000200", "B4000200", "B5000200", "B6000200", "B7000200", "B8000200", "B9000200", "BA000200", "18010200", "19010200", "1A010200", "1C010200", "1D010200", "1E010200", "1F010200", "20010200", "21010200", "23010200", "24010200", "26010200", "27010200", "28010200", "29010200", "2A010200", "2C010200", "2D010200"];
    especialUNISEX = ["01800300", "02800300", "03800300", "04800300", "05800300", "06800300", "07800300", "08800300", "09800300", "0A800300", "0B800300", "0C800300", "0D800300", "0E800300", "0F800300", "10800300", "11800300", "12800300", "13800300", "14800300", "15800300", "16800300", "17800300", "18800300", "19800300", "1A800300", "1B800300", "1C800300", "1D800300", "1E800300", "1F800300", "20800300", "21800300", "22800300", "23800300", "24800300", "25800300", "26800300", "27800300", "28800300", "29800300", "2A800300", "2B800300", "2C800300", "2D800300", "2E800300", "2F800300", "30800300", "31800300", "32800300", "33800300", "34800300", "35800300", "36800300", "37800300", "38800300", "39800300", "3A800300", "3B800300", "3C800300", "3D800300", "3E800300", "3F800300", "41800300", "42800300", "43800300", "44800300", "45800300", "46800300", "47800300", "48800300", "49800300", "4B800300", "4C800300", "4D800300", "4E800300", "4F800300", "50800300", "51800300", "52800300", "53800300", "54800300", "55800300", "56800300", "57800300", "58800300", "5B800300", "5C800300", "5D800300", "5E800300", "62800300", "63800300", "64800300", "65800300", "66800300", "67800300", "68800300", "69800300", "6A800300", "6B800300", "6C800300", "6D800300", "6E800300", "6F800300", "70800300", "71800300", "72800300", "73800300", "74800300", "75800300", "76800300", "77800300", "78800300", "79800300", "7A800300", "7B800300", "7C800300", "7D800300", "7E800300", "7F800300", "80800300", "81800300", "82800300", "83800300", "84800300", "85800300", "86800300", "87800300", "88800300", "89800300", "8A800300", "98800300", "99800300", "9A800300", "9B800300", "9C800300", "9D800300", "9E800300", "9F800300", "A0800300", "A1800300", "A2800300", "A4800300", "A5800300", "A6800300", "A7800300", "A8800300", "A9800300", "AA800300", "AB800300", "AC800300", "AD800300", "AE800300", "AF800300", "B0800300", "B1800300", "B2800300", "B3800300", "B4800300", "B5800300", "B6800300", "B7800300", "BD800300", "BE800300", "BF800300", "C0800300", "C1800300", "C2800300", "C4800300", "C5800300", "C6800300", "C9800300", "CA800300", "CB800300", "CC800300", "CD800300", "CE800300", "CF800300", "D0800300", "D1800300", "D2800300", "D3800300", "D4800300", "D5800300", "D6800300", "D7800300", "D8800300", "D9800300", "DA800300", "DB800300", "DC800300", "DD800300", "DE800300", "DF800300", "E0800300", "E1800300", "F7800300", "F8800300", "FB800300", "0B810300", "0F810300", "18810300", "19810300", "1A810300", "1F810300", "24810300", "2D810300", "2E810300", "36810300", "38810300", "39810300", "3A810300", "3B810300", "3C810300", "3D810300", "3E810300", "3F810300", "41810300", "42810300", "46810300", "49810300", "4A810300", "4E810300", "4F810300", "50810300", "51810300", "52810300", "53810300", "54810300", "55810300", "56810300", "57810300", "58810300", "5B810300", "5C810300", "5F810300", "60810300", "61810300", "62810300", "63810300", "6B810300", "6C810300", "6F810300", "70810300", "71810300", "72810300", "73810300", "74810300", "75810300", "76810300", "79810300", "7A810300", "7C810300", "7E810300", "7F810300", "80810300", "81810300", "82810300", "83810300", "84810300", "85810300", "86810300", "87810300", "88810300", "89810300", "8A810300", "8B810300", "8C810300", "8D810300", "8E810300", "8F810300", "90810300", "91810300", "92810300", "93810300", "94810300", "96810300", "97810300", "99810300", "9A810300", "9B810300", "9C810300", "9D810300", "9E810300", "9F810300", "A0810300", "A1810300", "A4810300", "A5810300", "A6810300", "A7810300", "A8810300", "AA810300", "AB810300", "AC810300", "AD810300", "AE810300", "AF810300", "B0810300", "B1810300", "B2810300", "B3810300", "B4810300", "B5810300", "B6810300", "B7810300", "B8810300", "B9810300", "BA810300", "BB810300", "BC810300", "BD810300", "BE810300", "BF810300", "C0810300", "C1810300", "C2810300", "C3810300", "C4810300", "C5810300", "C6810300", "C7810300", "C8810300", "C9810300", "CA810300", "CB810300", "CC810300", "CD810300", "CE810300", "CF810300", "D0810300", "D1810300", "D2810300", "D3810300", "D4810300", "D5810300", "F6810300", "F7810300", "F8810300", "F9810300", "FA810300", "FB810300", "FC810300", "FD810300", "FE810300", "FF810300", "00820300", "01820300", "02820300", "03820300", "04820300", "05820300", "06820300", "07820300", "08820300", "09820300", "0A820300", "0B820300", "0C820300", "0D820300", "0E820300", "0F820300", "10820300", "11820300", "12820300", "13820300", "14820300", "15820300", "16820300", "17820300", "18820300", "19820300", "1A820300", "1B820300", "1C820300", "1D820300", "1E820300", "1F820300", "20820300", "21820300", "22820300", "23820300", "24820300", "25820300", "26820300", "27820300", "28820300", "29820300", "2A820300", "2B820300", "2C820300", "2D820300", "2E820300", "2F820300", "30820300", "31820300", "32820300", "33820300", "34820300", "35820300", "36820300", "37820300", "38820300", "39820300", "3A820300", "3B820300", "3C820300", "3D820300", "3E820300", "3F820300", "40820300", "41820300", "42820300", "43820300", "44820300", "45820300", "46820300", "47820300", "48820300", "49820300", "4A820300", "4B820300", "4C820300", "4D820300", "4E820300", "4F820300", "50820300", "51820300", "52820300", "60820300", "6A820300", "6B820300", "7A820300", "7B820300", "7C820300", "7D820300", "82820300", "84820300", "85820300", "88820300", "89820300", "8A820300", "8B820300", "8C820300", "8D820300", "8E820300", "8F820300", "90820300", "91820300", "92820300", "93820300", "94820300", "95820300", "96820300", "97820300", "98820300", "99820300", "9A820300", "9B820300", "9C820300", "9D820300", "9E820300", "9F820300", "A0820300", "A1820300", "AA820300", "AB820300", "AC820300", "AD820300", "AE820300", "AF820300"];
    
    chapel = random.choice(chapelMASCULINO)
    roupa = random.choice(roupaMASCULINO)
    oculos = random.choice(oculosMASCULINO)
    especial = random.choice(especialUNISEX)

    if genero == "f":
        chapel = random.choice(chapelFEMININO)
        roupa = random.choice(roupaFEMININO)
        oculos = random.choice(oculosFEMININO)

    
    return "" + chapel + "" + roupa + "" + oculos + "" + especial + ""
    
    
    
    

# convert a bytes-like input into a hex-string
def bytes_to_hex(input_bytes):
    return "".join("{:02X}".format(b) for b in input_bytes)


# convert an integer into a series of little-endian bytes
def int_to_bytes(input_integer, size):
    # LSB on left (little endian)
    output_bytes = bytearray()
    for i in range(size):
        output_bytes.append(input_integer & 0xff)
        input_integer = input_integer >> 8
    return output_bytes


# convert a series of bytes into a little-endian integer given a size
def bytes_to_int(input_bytes, size):
    # parsed as little endian
    if len(input_bytes) < size:
        print("bytes_to_int: tamanho solicitado e menor que bytes de entrada")
        return 0
    output_int = 0
    for i in range(size):
        output_int |= input_bytes[i] << (i * 8)
    return output_int


# internally used in resize_bytes
def pad_bytes(input_bytes, desired_size):
    output = bytearray()
    output.extend(input_bytes)
    output.extend(bytearray.fromhex("00" * (desired_size - len(output))))
    return output


# internally used in resize_bytes
def truncate_bytes(input_bytes, desired_size):
    if len(input_bytes) > desired_size:
        return input_bytes[:desired_size]


# extends (pad: 00) or clips a bytes-like input to fit the desired size
def resize_bytes(input_bytes, desired_size):
    if len(input_bytes) > desired_size:
        return input_bytes[:desired_size]
    else:
        return pad_bytes(input_bytes, desired_size)


# goes through as many bytes as possible and creates a string, stopping at the first null terminator
def string_decode(input_bytes):
    result = ""
    for input_byte in input_bytes:
        if input_byte != 0:
            result += chr(input_byte)
        else:
            return result
    return result


# converts a string IP into a bytes representation
def ip_to_bytes(in_ip):
    ip_bytes = bytearray()
    ip_bytes.extend(map(int, in_ip.split('.')))
    return ip_bytes


class FunctionRestrict:
    AVATAR_ENABLED: int = 1 << 4
    EFFECT_FORCE: int = 1 << 13
    EFFECT_TORNADO: int = 1 << 14
    EFFECT_LIGHTNING: int = 1 << 15
    EFFECT_WIND: int = 1 << 16
    EFFECT_THOR: int = 1 << 17
    EFFECT_MOON: int = 1 << 18
    EFFECT_ECLIPSE: int = 1 << 19
    EVENT1_ENABLE: int = 1 << 20
    EVENT2_ENABLE: int = 1 << 21
    EVENT3_ENABLE: int = 1 << 22
    EVENT4_ENABLE: int = 1 << 23

    @staticmethod
    def get_function_value(effect_flags):
        result_function_out: int = 0
        for effect_flag in effect_flags:
            result_function_out |= effect_flag
        return result_function_out


# class Avatar:
#     @staticmethod
#     def get_avatar_by_user(in_username):
#         user_extended_avatar = []
#         if in_username == "saneusername":
#             user_extended_avatar.append(bytes.fromhex("0100 0100"))  # space marine (H)
#             user_extended_avatar.append(bytes.fromhex("0100 0000"))  # space marine (B)
#             user_extended_avatar.append(bytes.fromhex("0100 0200"))  # battle goggles (E)
#             user_extended_avatar.append(bytes.fromhex("0180 0300"))  # blue flag (F)
#             user_extended_avatar.append(bytes.fromhex("8F80 0100"))  # love cupid M (F)
#             user_extended_avatar.append(bytes.fromhex("0380 0300"))  # violet flag (F)
#         if in_username == "amigos":
#             user_extended_avatar.append(bytes.fromhex("A5800100"))
#             user_extended_avatar.append(bytes.fromhex("4B800000"))
#             user_extended_avatar.append(bytes.fromhex("3D800200"))
#             user_extended_avatar.append(bytes.fromhex("3D800300"))
#         return user_extended_avatar


class Room:
    room_id: int = -1
    room_name = ""
    password = ""
    map_id = 0
    game_settings = bytes.fromhex("00 00 00 00")
    occupants_max = 0
    room_state = 0  # waiting: 0, play: 1
    player_sessions = []

    def __init__(self, in_id, in_room_name, in_password, in_map_id, in_game_settings, in_occupants_max):
        self.room_id = in_id
        self.room_name = in_room_name
        self.password = in_password
        self.map_id = in_map_id
        self.game_settings = in_game_settings
        self.occupants_max = in_occupants_max
        self.player_sessions = []

    @staticmethod
    def find_room_position(in_world_room):
        # find a free room id
        for index in range(0xFF):
            index_is_occupied = False
            for room_item in in_world_room:
                if room_item.room_id == index:
                    index_is_occupied = True
                    break
            if not index_is_occupied:
                return index
        print("Nenhum ID de sala disponivel")
        return 0

    @staticmethod
    def find_room_slot(in_room):
        # find a free room id
        for index in range(0x10):
            index_is_occupied = False
            for session_item in in_room.player_sessions:
                if session_item.room_slot == index:
                    index_is_occupied = True
                    break
            if not index_is_occupied:
                return index
        print("Nao ha slots de sala disponiveis")
        return 0

    @staticmethod
    def find_room_team(in_room):
        # find a team to insert a new player
        team_a_size = 0
        team_b_size = 0
        for session_item in in_room.player_sessions:
            if session_item.room_team == 0:
                team_a_size += 1
            else:
                team_b_size += 1

        if team_a_size > team_b_size:
            return 1
        else:
            return 0

    @staticmethod
    def find_room_by_id(in_world_room, room_id):
        for room_item in in_world_room:
            if room_item.room_id == room_id:
                return room_item
        return None

    @staticmethod
    def find_room_by_user(in_world_room, in_username):
        for room_item in in_world_room:
            for player in room_item.player_sessions:
                if player.user.username == in_username:
                    return room_item
        return None

    @staticmethod
    def remove_session(in_world_room, in_username):
        for room_item in in_world_room:
            for player_index in range(len(room_item.player_sessions)):
                if room_item.player_sessions[player_index].user.username == in_username:
                    room_item.player_sessions.pop(player_index)
                    # destroy room if last player has quit
                    return True
        return False

    @staticmethod
    def remove_empty_rooms(in_world_room):
        cleanup_still_required = True

        while cleanup_still_required:
            for in_room_index in range(len(in_world_room)):
                if len(in_world_room[in_room_index].player_sessions) == 0:
                    in_world_room.pop(in_room_index)
                    break
            else:
                cleanup_still_required = False


class User:
    username = ""
    password = ""
    guild = ""
    rank_current = 10
    rank_season = 10
    cash: int = 9999999
    gold: int = 9999999

    # 2 types of avatars - equipped (WORD) and extended (DWORD)
    # extended:
    # first (LSB) and second byte are the shortened avatar code
    # shortened avatar code's LSB is 0 when no avatar is worn
    # second byte's most significant bit determines gender (1=male)
    # third byte describes the slot (body: 0, head: 1, eye: 2, flag: 3)
    # fourth byte (MSB) is unknown, maybe upper byte of slot (3rd byte)
    # equipped:
    # truncate extended avatar from DWORD to WORD. 4x for head, body, eye and flag
    avatar_equipped = bytes.fromhex("00 80 00 80 00 80 00 00")
    avatar_inventory = []  # list of DWORD-sized bytes

    def __init__(self, in_username, in_guild, in_rank_current):
        self.username = in_username
        self.password = in_username
        self.guild = in_guild
        # self.gender = in_gender  # gender is not used for now - see avatar bytes
        self.rank_current = in_rank_current
        self.rank_season = 10
        self.avatar_equipped = bytes.fromhex("00 80 00 80 00 80 00 00")  # default: male
        self.avatar_inventory = []

    @staticmethod
    

    def get_users(in_username):

        user_instances = []
        
        avatar_random = gerar_avatar_random("m")
        
        if(in_username != 0):
            user_instance: User = User(in_username, "HUMANO", randint(-4, 20))
            user_instance.avatar_equipped = bytes.fromhex("" + avatar_random[8:12] + "" + avatar_random[0:4] + "" + avatar_random[16:20] + "" + avatar_random[24:28] + "")
            user_instance.avatar_inventory = [bytes.fromhex(avatar_random[0:8]),bytes.fromhex(avatar_random[8:16]),bytes.fromhex(avatar_random[16:24]),bytes.fromhex(avatar_random[24:32])]
            user_instances.append(user_instance)
                
       
        with open("Temporarios\TXT_Bots.txt") as data_text:
            data = json.load(data_text)
            for json_row in data:
                user_instance: User = User(json_row["id"], "BOT", randint(-4, 20))
                
                genero = "0080008000800000"
                if json_row["genero"] == "f":
                    genero = "0000000000000000"
                
                user_instance.avatar_equipped = bytes.fromhex(genero)
                user_instances.append(user_instance) 
        
        with open("Temporarios\TXT_Contas.txt", encoding="utf8") as user_data_text:
            data_users = json.load(user_data_text)
            for data_user in data_users:
                user_instance: User = User(data_user["id"], data_user["cla"], data_user["rank"])
                user_instance.avatar_equipped = bytes.fromhex(data_user["avatar_equipado"])
                for user_avatar_inventoryitem in data_user["avatar_comprado"]:
                    user_instance.avatar_inventory.append(bytes.fromhex(user_avatar_inventoryitem))
                # print(user_instance, user_instance.username)
                user_instances.append(user_instance)
        return user_instances

    @staticmethod
    def get_user_by_name(in_world_user, in_username):
        for user_item in in_world_user:
            if user_item.username == in_username:
                return user_item
        return None

    def to_json(self):
        return json.dumps(User.user_to_serializable(self))

    @staticmethod
    def user_to_serializable(in_user):
        data_to_serialize = {}
        data_to_serialize["id"] = in_user.username
        data_to_serialize["cla"] = in_user.guild
        data_to_serialize["rank"] = in_user.rank_current
        data_to_serialize["avatar_equipado"] = bytes_to_hex(in_user.avatar_equipped)
        inventory_to_serialize = []
        for avatar_item in in_user.avatar_inventory:
            inventory_to_serialize.append(bytes_to_hex(avatar_item))

        data_to_serialize["avatar_comprado"] = inventory_to_serialize
        return data_to_serialize

    @staticmethod
    def save_users(in_user_list):
        users_to_serialize = []
        
        for user_item in in_user_list:
            if user_item.guild != "ADMIN" and user_item.guild != "BOT":
                users_to_serialize.append(User.user_to_serializable(user_item))
        
        print(json.dumps(users_to_serialize))
        
        with open("Temporarios\TXT_Contas.txt", "w") as data_file_handle:
            data_file_handle.write(json.dumps(users_to_serialize))
        
        print("Salvamento concluido")


class Session:
    auth_token = bytearray()
    session_unique = bytearray()
    user: User = None
    channel_position = -1
    client_version = 0
    socket_tx_sum = 0
    client = None
    address = None

    # room stuff
    is_room_key = False
    room_slot = -1
    room_team = 0
    room_tank_primary = 0xFF
    room_tank_secondary = 0xFF

    def __init__(self, client_socket, in_address):
        self.auth_token = secrets.token_bytes(4)
        self.session_unique = secrets.token_bytes(4)
        self.client = client_socket
        self.address = in_address
        self.room_slot = -1
        self.is_room_key = False
        #print("Nova sessao inicializada")
        if self.client is not None:
            print("Nova sessao inicializada")
            print("IP da sessao:", self.address[0], "Porta:", self.address[1])

    def decrypt(self, encrypted_bytes, client_command):
        return PY_ServidorGB_Criptografia.gunbound_dynamic_decrypt(
            encrypted_bytes, self.user.username, self.user.password, self.auth_token, client_command)

    def encrypt(self, plain_bytes, client_command):
        # align to encryption block size
        mutable_plain_bytes = bytearray()
        mutable_plain_bytes.extend(plain_bytes)
        for unused_pad_byte in range(12 - (len(plain_bytes) % 12)):
            mutable_plain_bytes.append(0x00)

        return PY_ServidorGB_Criptografia.gunbound_dynamic_encrypt(
            mutable_plain_bytes, self.user.username, self.user.password, self.auth_token, client_command)

    def send(self, command, bytes_to_send, rtc=None):
        payload = None
        if rtc is None:
            payload = Session.generate_packet(self.socket_tx_sum, command, bytes_to_send)
        else:
            mutable_bytes_to_send = bytearray()
            mutable_bytes_to_send.extend(int_to_bytes(rtc, 2))
            mutable_bytes_to_send.extend(bytes_to_send)
            payload = Session.generate_packet(self.socket_tx_sum, command, mutable_bytes_to_send)

        if self.client is None:
            #print("ENVIADO solicitado no bot, ignorando")
            return
        self.client.send(payload)
        print("ENVIADO>> ", hex(command), bytes_to_hex(payload))
        self.socket_tx_sum += len(payload)

    def send_encrypted(self, command, bytes_to_send, rtc=None):
        self.send(command, self.encrypt(bytes_to_send, command), rtc=rtc)

    # Generate a valid packet (header with length, sequence, command) with a given payload
    @staticmethod
    def generate_packet(sent_packet_length, command, data_bytes):
        packet_expected_length = len(data_bytes) + 6
        packet_sequence = Session.get_sequence(sent_packet_length + packet_expected_length)

        response = bytearray()
        response.extend(int_to_bytes(packet_expected_length, 2))
        response.extend(int_to_bytes(packet_sequence, 2))
        response.extend(int_to_bytes(command, 2))

        response.extend(data_bytes)
        return response

    # Gunbound packet sequence, generated from sum of packet lengths
    @staticmethod
    def get_sequence(sum_packet_length):
        return (((sum_packet_length * 0x43FD) & 0xFFFF) - 0x53FD) & 0xFFFF

    @staticmethod
    def get_session(in_world_session, in_username):
        for session_item in in_world_session:
            if session_item.user.username == in_username:
                return session_item
        return None

    @staticmethod
    def remove_session(in_world_session, in_username):
        for index in range(len(in_world_session)):
            if in_world_session[index].user.username == in_username:
                in_world_session.pop(index)

    @staticmethod
    def find_channel_position(in_world_session):
        # find a new channel position
        for index in range(0xFF):
            index_is_occupied = False
            for session_item in in_world_session:
                if session_item.channel_position == index:
                    index_is_occupied = True
                    break
            if not index_is_occupied:
                return index
        print("Nenhum slot de canal disponivel")
        return 0

    @staticmethod
    def find_highest_channel_position(in_world_session):
        highest_position = 0
        for session_item in in_world_session:
            if session_item.channel_position > highest_position:
                highest_position = session_item.channel_position
        return highest_position

    @staticmethod
    def sendall(in_world_session, in_command, in_data):
        for session_item in in_world_session:
            session_item.send(in_command, in_data)


class GameUDPServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind((self.host, self.port))
        print("Limite de UDP")

    def listen(self):
        while True:
            udp_payload, udp_client_address = self.sock.recvfrom(1024)
            print("UDP: ecoando dados de volta para " + str(udp_client_address), bytes_to_hex(udp_payload))
            self.sock.sendto(udp_payload, udp_client_address)
            print("UDP Concluido")


class CommandProcessor:
    world_session = []
    world_room = []
    parent_instance = None

    def __init__(self, in_world_session, in_world_room, in_parent_instance):
        self.world_session = in_world_session
        self.world_room = in_world_room
        self.parent_instance = in_parent_instance

    def join_channel(self, data, client_session, motd_channel):
        # check where the player was previously from - if from game/room, clean up
        if client_session.room_slot != -1:
            print("Limpeza do SALA solicitada")
            previous_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
            new_keybearer_session: Session = None
            for session_item in previous_room.player_sessions:
                if session_item.user.username != client_session.user.username:
                    new_keybearer_session = session_item
                    break

            migration_packet = bytearray()
            if new_keybearer_session is not None:
                # if host leaves the room, the packet is never built or sent
                # team A/B data seems to get messy after this
                migration_packet.append(new_keybearer_session.room_slot)
                migration_packet.append(len(previous_room.room_name))
                migration_packet.extend(previous_room.room_name.encode("ascii"))
                migration_packet.append(previous_room.map_id)
                migration_packet.extend(previous_room.game_settings)
                migration_packet.extend(bytes.fromhex("FF FF FF FF FF FF FF FF"))  # unknown
                migration_packet.append(previous_room.occupants_max)  # guessed

            for session_item in previous_room.player_sessions:
                if session_item.user.username != client_session.user.username:
                    print("Enviando pacote de migracao")
                    session_item.send(0x3020, int_to_bytes(client_session.room_slot, 2))
                    # assuming 3040 is a broadcast since everyone needs to know of key migration
                    session_item.send(0x3400, migration_packet)

            if Room.remove_session(self.world_room, client_session.user.username):
                Room.remove_empty_rooms(self.world_room)
                print("Limpeza da sala concluida com sucesso")
            else:
                print("Limpeza da sala solicitada, mas falhou")

            client_session.room_slot = -1
            client_session.is_room_key = False

        # last 2 bytes indicate desired channel LSB MSB end
        desired_channel = bytes_to_int(data[-2:], 2)
        if desired_channel == 0xFFFF:
            # fresh login requesting for a free channel. In this case we will default to channel 1
            print("Novo login, roteamento para o canal 1", hex(desired_channel))
            desired_channel = 0
        extended_channel_motd = motd_channel + "\r\n" + "Hora Atual: " + datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")

        # find all ACTIVE channel participants (!= sessions). room_slot must be -1
        active_channel_users = []
        for session_item in self.world_session:
            if session_item.room_slot == -1:
                active_channel_users.append(session_item)

        channel_join_packet_new = bytearray()
        channel_join_packet_new.extend(bytes.fromhex("00 00"))
        channel_join_packet_new.extend(int_to_bytes(desired_channel, 2))
        channel_join_packet_new.append(Session.find_highest_channel_position(active_channel_users))
        channel_join_packet_new.append(len(active_channel_users))

        # channel participants are sessions with a room slot of -1 (aka not in a room)
        for session_item in active_channel_users:
            channel_player = bytearray()
            channel_player.append(session_item.channel_position)
            channel_player.extend(resize_bytes(session_item.user.username.encode("ascii"), 12))
            channel_player.extend(session_item.user.avatar_equipped)  # gender determined from avatar?
            channel_player.extend(resize_bytes(session_item.user.guild.encode("ascii"), 8))
            channel_player.extend(int_to_bytes(session_item.user.rank_current, 2))
            channel_player.extend(int_to_bytes(session_item.user.rank_season, 2))
            channel_join_packet_new.extend(channel_player)

        channel_join_packet_new.extend(extended_channel_motd.encode("ascii"))

        client_session.send(0x2001, channel_join_packet_new)

        # channel data DOES affect room state - whether tunnel will be used bc user cannot be found

        # advertise channel join to existing clients
        join_notification = bytearray()
        join_notification.append(client_session.channel_position)
        join_notification.extend(resize_bytes(client_session.user.username.encode("ascii"), 0xC))
        join_notification.extend(client_session.user.avatar_equipped)  # avatar
        join_notification.extend(resize_bytes(client_session.user.guild.encode("ascii"), 8))
        join_notification.extend(int_to_bytes(client_session.user.rank_current, 2))  # current rank
        join_notification.extend(int_to_bytes(client_session.user.rank_season, 2))  # season rank

        for session_item in active_channel_users:
            if session_item.user.username != client_session.user.username:
                session_item.send(0x200E, join_notification)

    def cash_update(self, client_session):
        # 1032: cash update
        # unknown dword in the middle, all zeroes
        # some sort of dword at the end of 0x1032
        # could be "crap" padding bytes to fit encryption's 12-byte block
        client_session.send_encrypted(0x1032, int_to_bytes(client_session.user.cash, 4))

    def print_to_client(self, client_session, in_message):
        client_session.send(0x5101, in_message.encode("ascii"))

    def room_update(self, client_session):
        client_session.send(0x3105, bytes.fromhex(""), rtc=0)

    def start_game_serv2(self, data, client_session):
        unknown_data = data[6:]  # A2 89 CB 01 / seems different every time, longer for multiplayer
        selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
        selected_room.room_state = 1  # waiting -> playing
        start_data = bytearray()

        # set the game's map
        if selected_room.map_id == 0:
            print("Rolando mapa aleatorio com", self.parent_instance.cave_map_chance_percentage, "%")
            if random.randint(0, 100) <= self.parent_instance.cave_map_chance_percentage:
                selected_room.map_id = 0  # special map (cave), assigning it for readability
            else:
                selected_room.map_id = random.randint(1, 10)
            start_data.append(selected_room.map_id)  # random, normal map
        else:
            start_data.append(selected_room.map_id)  # user-selected map

        current_map_data = None
        spawn_points = []  # can be overwritten in the future to support Mix / EvsW
        for map_row in self.parent_instance.map_data:
            if map_row["map_id"] == selected_room.map_id:
                current_map_data = map_row
                map_side_ab = selected_room.game_settings[2] & 1
                print("Lado do mapa (A=0, B=1):", map_side_ab)
                if map_side_ab == 0:
                    spawn_points = current_map_data["positions_a_side"]
                else:
                    spawn_points = current_map_data["positions_b_side"]
        # In Serv2, if ( numberOfPlayers <= 6 ), "Small Mode" is internally activated.
        # I am not sure what it does yet. Probably to prevent spawning players too far from each other

        print(current_map_data)
        print(spawn_points)

        # randomized spawn order list (8 possible spawn points)
        spawn_order = list(range(8))
        random.shuffle(spawn_order)
        print("Ordem de criacao/slot:", spawn_order)

        # randomized turn order list
        turn_order = list(range(len(selected_room.player_sessions)))
        random.shuffle(turn_order)
        print("Ordem de turno/slot:", turn_order)

        # below size of WORD seems excessive, value is guessed
        start_data.extend(int_to_bytes(len(selected_room.player_sessions), 2))
        for session_item in selected_room.player_sessions:
            # random bot selection
            # turns out that dragon and knight are 17/18 respectively, differing from Serv2's 14/15. Thanks @phnx
            if session_item.room_tank_primary == 0xFF:
                print("Rolando primario aleatorio com", self.parent_instance.special_bot_chance_percentage, "%")
                if random.randint(0, 100) <= self.parent_instance.special_bot_chance_percentage:
                    session_item.room_tank_primary = random.randint(17, 18)
                else:
                    session_item.room_tank_primary = random.randint(0, 13)
            if session_item.room_tank_secondary == 0xFF:
                print("Rolando secundario aleatorio com", self.parent_instance.special_bot_chance_percentage, "%")
                if random.randint(0, 100) <= self.parent_instance.special_bot_chance_percentage:
                    session_item.room_tank_secondary = random.randint(17, 18)
                else:
                    session_item.room_tank_secondary = random.randint(0, 13)

            start_data.append(session_item.room_slot)
            start_data.extend(resize_bytes(session_item.user.username.encode("ascii"), 0xC))
            start_data.append(session_item.room_team)
            start_data.append(session_item.room_tank_primary)
            start_data.append(session_item.room_tank_secondary)
            # Positional data: x (2 bytes), y (2 bytes). thanks @phnx
            player_spawn_point = spawn_points[spawn_order[session_item.room_slot]]  # default randomized spawn
            # player_spawn_point = spawn_points[7]  # override spawn position. use either this or the above line
            player_x = random.randint(player_spawn_point["x_min"], player_spawn_point["x_max"])
            player_y = 0 if player_spawn_point["y"] is None else player_spawn_point["y"]
            print("Ponto de reproducao do jogador:", player_spawn_point, "x:", player_x, "y", player_y)
            start_data.extend(int_to_bytes(player_x, 2))  # x position
            start_data.extend(int_to_bytes(player_y, 2))  # y position

            start_data.extend(int_to_bytes(turn_order[session_item.room_slot], 2))  # turn position. thanks @phnx
        # unknown: would guess FuncRestrict but it's short of a byte
        # default FFFF, setting 0000 activates event
        start_data.extend(bytes.fromhex("00 FF"))
        start_data.extend(unknown_data)  # echo the stuff sent by game host

        for session_item in selected_room.player_sessions:
            session_item.send_encrypted(0x3432, start_data)

    def start_game_gis(self, data, client_session):
        # GIS experiment
        unknown_data = data[6:]  # see start_game_serv2
        selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
        selected_room.room_state = 1  # waiting -> playing
        start_data = bytearray()
        # start_data.extend(selected_room.game_settings)
        # start_data.extend(bytes.fromhex("00 00 00 00"))

        start_data.extend(bytes.fromhex("00 00 00 00"))
        # start_data.extend(unknown_data)  # echo the stuff sent by game host

        start_data.append(selected_room.map_id)  # map
        # below size of WORD seems excessive, value is guessed
        start_data.extend(int_to_bytes(len(selected_room.player_sessions), 2))
        for session_item in selected_room.player_sessions:
            # random bot selection
            if session_item.room_tank_primary == 0xFF:
                session_item.room_tank_primary = random.randint(0, 13)
            if session_item.room_tank_secondary == 0xFF:
                session_item.room_tank_secondary = random.randint(0, 13)

            start_data.append(session_item.room_slot)
            start_data.extend(resize_bytes(session_item.user.username.encode("ascii"), 0xC))
            start_data.append(session_item.room_team)  # guessed
            start_data.append(session_item.room_tank_primary)  # comsik.txt: looks correct
            start_data.append(session_item.room_tank_secondary)
            # unknown positional data. looks nothing like the *_stage_pos.txt content
            # map position's theory:
            # grab the 8 possible slots from *_stage_pos.txt
            # if player count is below (?), enter "small mode", selecting denser slot positions
            # assign player's slot position (prefer alternating)
            # set the position below
            # right now i have no idea how this value works, so everyone uses the same value
            # as a consequence, everyone spawns on the same spot
            start_data.extend(bytes.fromhex("36 02 00 00"))
            start_data.append(session_item.room_slot)  # hack - this value needs incrementing
            start_data.append(0)  # hack
        # current event
        # default FFFF, setting 0000 activates event
        start_data.extend(bytes.fromhex("12 34"))
        # start_data.extend(unknown_data)  # echo the stuff sent by game host

        for session_item in selected_room.player_sessions:
            session_item.send_encrypted(0x3432, start_data)
        print("GIS: envio de dados estruturados")

    def start_game_anyhowly(self, data, client_session):
        # GIS experiments
        # this gets into game: cozy tower, bottom left (no foothold), solo, 1 other opponent
        # 0x3432,
        # 01010101 6A000101 01010101 01010101 01010101 01010101 01010101 01010101 01010101
        # position 4 (0-indexed): map
        # position 5, non-zero value
        # this gets into game: nirvana left side, 3 players
        # position 7: first player channel index
        # pos 24, 26 set first player x, y
        # 21, 22 = mobile 1, 2 (0B 0A)
        gamesession_data = bytearray()
        gamesession_data.extend(bytearray.fromhex("44 44 44 44 04 01 00 00 44 44 44 44"))
        gamesession_data.extend(bytearray.fromhex("44 44 11 22 33 44 55 66 77 0B 0A 00"))
        gamesession_data.extend(bytearray.fromhex("02 ff 02 55 55 55 55 55 55 55 55 55"))
        print("GIS: enviando dados confusos")
        client_session.send_encrypted(0x3432, gamesession_data)


class GameServer(object):
    host = None
    port = 0
    motd_channel = "\n\n----- INICIO COMANDOS DO GUNBOUND -----\n/help = Ver todos os Comandos\n/jogar = Iniciar Jogo Forcado\n/genero (m), (f) = Masculino - f = Feminino\n/mobile (0 = Armor), (1 = Mage), (2 = Nak), (3 = Trico)\n(4 = Bigfoot), (5 = Boomer), (6 = Raon)\n(7 = Lightning), (8 = J.D), (9 = A.Sate)\n(10 = Ice), (11 = Turtle), (12 = Grub)\n(13 = Aduka), 17 = Dragon), (18 = Knight)\n/msg #,*,$,%,^,&(mensagem) = Envia uma mensagem para todos.\n/conexao = Verifica se a conexao ainda esta ativa.\n/online = Verifica jogadores online agora.\n/salvar = Salva suas informacoes, por exemplo: avatares, gold...\n/fechar = Fechar sala atual\n/sair = Sair da sala atual\n/quit = Fechar jogo imediatamente\n----- FIM COMANDOS DO GUNBOUND -----\n\n"
    motd_room = "\n\n----- INICIO COMANDOS DO GUNBOUND -----\n/help = Ver todos os Comandos\n/jogar = Iniciar Jogo Forcado\n/genero (m), (f) = Masculino - f = Feminino\n/mobile (0 = Armor), (1 = Mage), (2 = Nak), (3 = Trico)\n(4 = Bigfoot), (5 = Boomer), (6 = Raon)\n(7 = Lightning), (8 = J.D), (9 = A.Sate)\n(10 = Ice), (11 = Turtle), (12 = Grub)\n(13 = Aduka), 17 = Dragon), (18 = Knight)\n/msg #,*,$,%,^,&(mensagem) = Envia uma mensagem para todos.\n/conexao = Verifica se a conexao ainda esta ativa.\n/online = Verifica jogadores online agora.\n/salvar = Salva suas informacoes, por exemplo: avatares, gold...\n/fechar = Fechar sala atual\n/sair = Sair da sala atual\n/quit = Fechar jogo imediatamente\n----- FIM COMANDOS DO GUNBOUND -----\n\n"
    special_bot_chance_percentage = 50  # normally 2% (2)
    cave_map_chance_percentage = 20  # normally 20% (20)
    map_data = []
    gs_funcrestrict = 0xFFFFF
    world_session = []
    world_room = []
    world_user = []
    
    command_processor: CommandProcessor = None

    def __init__(self, host, port, in_world_session, in_world_room, in_world_user):
        self.host = host
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind((self.host, self.port))

        self.world_session = in_world_session
        self.world_room = in_world_room
        self.world_user = in_world_user
        print("GAMESERVER: Limite TCP")

        self.map_data = GameServer.get_map_data()
        udp_server = GameUDPServer(host, port)
        threading.Thread(target=udp_server.listen).start()

        self.command_processor = CommandProcessor(self.world_session, self.world_room, self)
        self.adicionar_bots_no_canal()

    def listen(self):
        self.sock.listen(5)
        print("GAMESERVER: AGUARDANDO LOGS DA PORTA:", self.port)
        while True:
            client, address = self.sock.accept()
            client.settimeout(6000)
            threading.Thread(target=self.client_connection, args=(client, address)).start()


    def adicionar_bots_no_canal(self):
        # create lobby and channel test users
        
        virtual_bots = []
        with open("Temporarios\TXT_Bots.txt") as data_text:
            data = json.load(data_text)
            random.shuffle(data)
            for json_row in data:
                virtual_bots.append(json_row["id"])
        
        test_room = Room(randint(1, 100), "Sala dos Bots", "", 0, bytes.fromhex("B2620C00"), 4)
        
        contaBots = 0;
        for virtual_bot in virtual_bots:
            virtual_session = Session(None, None)
            virtual_session.user = User.get_user_by_name(self.world_user, virtual_bot)
            virtual_session.user.guild = "BOT"
            virtual_session.channel_position = Session.find_channel_position(self.world_session)
            
            if contaBots < 10:
                if contaBots < 4:
                    test_room.player_sessions.append(virtual_session)
                else:
                    self.world_session.append(virtual_session)
            
            contaBots += 1;
            
        self.world_room.append(test_room)
            

   

    @staticmethod
    def get_map_data():
        with open("Temporarios\TXT_Mapas.txt",  encoding="utf8") as map_data_text:
            return json.load(map_data_text)

    @staticmethod
    def solicitando_salas(self, client_session, data):
        # first byte: room filter type, 1 = all, 2 = waiting
        # direct room join is technically under filter: ALL (longer payload)
        room_filter_mode = data[6]
        if room_filter_mode == 1:
            print("Filtro: TODOS")
        elif room_filter_mode == 2:
            print("Filtro: AGUARDANDO")
        else:
            print("Filtro: DESCONHECIDO")

        # FIXME: room directory pagination is done on server
        # where is the "next/previous page is available" indicator?
        # client does strange things if more than 6 rooms are sent
        room_reply = bytearray()
        room_reply.extend(int_to_bytes(len(self.world_room), 2))
        # room_reply.append(len(self.world_room))
        # room_reply.append(0xFF)  # was hoping that this is the indicator for multiple pages..

        for room_item in self.world_room:
            room_entry = bytearray()
            room_entry.extend(int_to_bytes(room_item.room_id, 2))  # 0-indexed room number, as WORD
            room_entry.append(len(room_item.room_name))
            room_entry.extend(room_item.room_name.encode("ascii"))
            room_entry.append(room_item.map_id)  # map: 0 = random, 1 = miramo ..
            room_entry.extend(room_item.game_settings)  # example bytes: B2620C00
            room_entry.append(len(room_item.player_sessions))  # occupant count
            room_entry.append(room_item.occupants_max)  # max occupants
            room_entry.append(room_item.room_state)  # play state or ready (play = 1, waiting = 0)
            if len(room_item.password) > 0:
                room_entry.append(1)  # room locked: 1 = password required
            else:
                room_entry.append(0)  # room locked: 0 = default open
            room_reply.extend(room_entry)

        client_session.send(0x2103, room_reply, rtc=0)



    def client_connection(self, client, address):
        print("GAMESERVER: Nova conexao de", address)
        socket_rx_size = 1024
        client_session = Session(client, address)
        socket_rx_sum = 0
        


        while True:
            try:
                data = client.recv(socket_rx_size)
                if data:
                    if len(data) < 6:
                        print("RECEBIDO BROKEN PACKET>>")
                        print(bytes_to_hex(data))
                    else:
                    
                    
                        # Try parse basic packet information
                        payload_size = bytes_to_int(data[0: 2], 2)
                        # sequence = bytes_to_int(data[2:4], 2)
                        client_command = bytes_to_int(data[4:6], 2)

                        print("")
                        print("RECEBIDO>> ", hex(client_command), bytes_to_hex(data[6:]))

                        socket_rx_sum += payload_size

                        #self.command_processor.print_to_client(client_session, "Acesse thalles.net/gb para mais informacoes.")

                        # Reply client if the service request is recognized
                        if client_command == 0x1000:
                            # uncomment below for debug token override - INSECURE
                            # client_session.auth_token = bytes.fromhex("00 98 6B C4")
                            print("Token gerado:", bytes_to_hex(client_session.auth_token))
                            client_session.send(0x1001, client_session.auth_token)

                        elif client_command == 0x0000:
                            print("RECEBIDO> KEEPALIVE")

                        elif client_command == 0x1010:
                            print("RECEBIDO> SVC_LOGIN/ADMIN")

                            username_bytes = PY_ServidorGB_Criptografia.gunbound_static_decrypt(data[6:6 + 0x10])
                            queried_user = User.get_user_by_name(self.world_user, string_decode(username_bytes))

                            if queried_user is None:
                                # User not found, send disconnection packet
                                print("O nome de usuario nao existe, criando uma nova conta...")
                                
                                self.world_user = User.get_users(string_decode(username_bytes))
                                User.save_users(self.world_user)
                                
                                username_bytes = PY_ServidorGB_Criptografia.gunbound_static_decrypt(data[6:6 + 0x10])
                                queried_user = User.get_user_by_name(self.world_user, string_decode(username_bytes))
                                
                                #client_session.send(0x1012, bytes.fromhex("10 00"))
                            
                            
                            # future: check user if already logged in, *across worlds*
                            client_session.user = queried_user
                            dynamic_payload = client_session.decrypt(data[6 + 0x20:], client_command)
                            
                            print("Nome do usuario:", client_session.user.username)

                            client_session.client_version = dynamic_payload[0x14] | (dynamic_payload[0x15] << 8)
                            #print("Versao do cliente", client_session.client_version)
                            client_session.channel_position = Session.find_channel_position(self.world_session)
                            # client_session.channel_position = 0x0a
                            self.world_session.append(client_session)
                            login_packet = bytearray()
                            login_packet.extend(bytearray.fromhex("00 00"))  # maybe gender?
                            login_packet.extend(client_session.session_unique)  # "seems unused
                            login_packet.extend(resize_bytes(client_session.user.username.encode("ascii"), 0xC))
                            login_packet.extend(client_session.user.avatar_equipped)  # currently worn avatar
                            login_packet.extend(resize_bytes(client_session.user.guild.encode("ascii"), 8))
                            login_packet.extend(int_to_bytes(client_session.user.rank_current, 2))
                            login_packet.extend(int_to_bytes(client_session.user.rank_season, 2))
                            login_packet.extend(int_to_bytes(5, 2))  # guild member count
                            login_packet.extend(int_to_bytes(1, 2))  # rank position, current
                            login_packet.extend(int_to_bytes(0, 2))  # ?
                            login_packet.extend(int_to_bytes(1, 2))  # rank position, season
                            login_packet.extend(int_to_bytes(0, 2))  # ?
                            login_packet.extend(int_to_bytes(1, 2))  # individual's guild rank
                            # most likely shot history, vs mobile etc.
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.extend(bytearray.fromhex("00000000 00000000 0000"))
                            login_packet.extend(int_to_bytes(1, 4))  # gp, current
                            login_packet.extend(int_to_bytes(1, 4))  # gp, season
                            login_packet.extend(int_to_bytes(client_session.user.gold, 4))  # gold
                            # unknown
                            login_packet.extend(bytearray.fromhex("00000000 00000000 00000000 00000000"))
                            login_packet.append(0)  # still unknown
                            login_packet.extend(int_to_bytes(self.gs_funcrestrict, 4))  # weather, event etc
                            if client_session.client_version == 313 or client_session.client_version == 376:
                                # GIS protocol - throwing in cash state to appease client
                                # this is an odd packet combining both encrypted and plain data
                                login_packet.extend(client_session.encrypt(
                                    int_to_bytes(client_session.user.cash, 4), 0x1012))

                            client_session.send(0x1012, login_packet)

                            self.command_processor.cash_update(client_session)

                            if client_session.client_version == 313 or client_session.client_version == 376:
                                # force GIS to change state; reply from channel join does that
                                self.command_processor.join_channel(data, client_session, self.motd_channel)

                        elif client_command == 0x1020:
                            print("RECEBIDO> SVC_USER_ID")
                            payload_data = client_session.decrypt(data[6:], 0x1020)
                            requested_username = string_decode(payload_data[0:0xC])
                            found_id = User.get_user_by_name(self.world_user, requested_username)
                            print("Consultando para", requested_username)
                            
                            if found_id is None:
                                print("Nenhum usuario encontrado:", requested_username)
                            
                            else:
                                print("ID encontrado:", found_id.username)
                                # if an id is not found, everything below should be automatically 0
                                # we don't distinguish between login/game id, so echo the request back
                                # 1020 is unusual as it requires a user to be authenticated before use (for crypto)
                                id_crypted_response = bytearray()
                                id_crypted_response.extend(resize_bytes(found_id.username.encode("ascii"), 0xC))
                                id_crypted_response.extend(resize_bytes(found_id.username.encode("ascii"), 0xC))
                                # guild (8 bytes)
                                id_crypted_response.extend(resize_bytes(found_id.guild.encode("ascii"), 8))
                                # current rank (2 bytes), season rank (2 bytes)
                                id_crypted_response.extend(int_to_bytes(found_id.rank_current, 2))
                                id_crypted_response.extend(int_to_bytes(found_id.rank_season, 2))
                                client_session.send_encrypted(0x1021, id_crypted_response, rtc=0)

                        elif client_command == 0x2000:
                        
                            print("RECEBIDO> ENTROU EM UM CANAL")
                            self.command_processor.join_channel(data, client_session, self.motd_channel)

                            print("NOVOS USUARIOS CARREGADOS")
                            world_user = User.get_users(0)
                            

                        elif client_command == 0x2100:
                            
                            print("RECEBIDO> SOLICITANDO SALAS")
                            GameServer.solicitando_salas(self, client_session, data);
                            
                        elif client_command == 0x2104:
                        
                            print("RECEBIDO> DETALHE DA SALA")
                            requested_room_id = bytes_to_int(data[6:], 2)
                            requested_room = Room
                            for room_item in self.world_room:
                                if room_item.room_id == requested_room_id:
                                    requested_room = room_item
                                    print("Sala encontrada")
                                    break
                            response = bytearray()
                            # see command 0x2100 - same stuff with user details appended
                            response.append(len(requested_room.room_name))
                            response.extend(requested_room.room_name.encode("ascii"))
                            response.append(requested_room.map_id)  # map: 0 = random, 1 = miramo ..
                            response.extend(requested_room.game_settings)
                            response.append(len(requested_room.player_sessions))  # occupant count
                            response.append(requested_room.occupants_max)  # max occupants
                            response.append(requested_room.room_state)  # play state
                            if len(requested_room.password) > 0:
                                response.append(1)  # room locked: 1 = password required
                            else:
                                response.append(0)  # room locked: 0 = default open

                            for room_player in requested_room.player_sessions:
                                response.extend(resize_bytes(room_player.user.username.encode("ascii"), 0xC))
                                response.extend(room_player.user.avatar_equipped)  # currently worn avatar
                                response.extend(resize_bytes(room_player.user.guild.encode("ascii"), 8))
                                response.extend(int_to_bytes(room_player.user.rank_current, 2))
                                response.extend(int_to_bytes(room_player.user.rank_season, 2))

                            # decent chunk copied from 0x2100
                            client_session.send(0x2105, response, rtc=0)
                            
                            GameServer.solicitando_salas(self, client_session, data);


                        elif client_command == 0x2110:
                            print("RECEBIDO> ENTROU NA SALA")
                            # first 2 bytes are requested room number, suBROKERSERVERequent: join password
                            requested_room_id = bytes_to_int(data[6:8], 2)
                            requested_room_password = string_decode(data[8:])
                            # future: check if room id actually exists, and verify password
                            requested_room: Room = Room.find_room_by_id(self.world_room, requested_room_id)

                            if requested_room is None:
                                print("Solicitou uma sala invalida. As coisas vao quebrar")
                                self.command_processor.print_to_client(client_session, "A sala nao existe, atualizando lista de salas...")

                                GameServer.solicitando_salas(self, client_session, data);
                                
                            else:
                                client_session.room_team = Room.find_room_team(requested_room)
                                client_session.room_slot = Room.find_room_slot(requested_room)
                                client_session.room_tank_primary = 0xFF
                                client_session.room_tank_secondary = 0xFF
                                requested_room.player_sessions.append(client_session)

                                client_ip = ip_to_bytes(client_session.address[0])
                                client_port = bytes.fromhex("20 AB")  # 8363 seems to be hardcoded
                                print(client_session.user.username, "-", requested_room_id, requested_room_password)

                                # decent chunk copied from 0x2100
                                # 20AB = port 8363, client listens there for UDP

                                # respond to the client first
                                # the start of the client_join_request are room-specific details
                                # how does the client know who the host is?
                                client_session.send(0x21F5, bytes.fromhex("03"), rtc=0)  # unknown - why 3?
                                client_join_request = bytearray()
                                client_join_request.extend(int_to_bytes(0, 2))  # probably RTC but not sure
                                client_join_request.extend(int_to_bytes(0x0100, 2))  # unknown
                                client_join_request.extend(int_to_bytes(requested_room.room_id, 2))  # probably room id
                                client_join_request.append(len(requested_room.room_name))
                                client_join_request.extend(requested_room.room_name.encode("ascii"))
                                client_join_request.append(requested_room.map_id)
                                client_join_request.extend(requested_room.game_settings)
                                client_join_request.extend(bytes.fromhex("FF FF FF FF FF FF FF FF"))  # 4x WORDs?
                                # a bit unusual that occupants_max comes before number of players, normally swapped
                                # unless everything else is wrong..
                                client_join_request.append(requested_room.occupants_max)
                                client_join_request.append(len(requested_room.player_sessions))

                                for session_item in requested_room.player_sessions:
                                    session_ip = ip_to_bytes(session_item.address[0])
                                    client_join_request.append(session_item.room_slot)
                                    client_join_request.extend(resize_bytes(session_item.user.username.encode("ascii"), 0xC))
                                    client_join_request.extend(session_ip)
                                    client_join_request.extend(client_port)
                                    client_join_request.extend(session_ip)
                                    client_join_request.extend(client_port)
                                    client_join_request.append(session_item.room_tank_primary)  # primary tank
                                    client_join_request.append(session_item.room_tank_secondary)  # secondary tank
                                    client_join_request.append(session_item.room_team)  # team side (0 = A, 1 = B)
                                    client_join_request.append(0x01)  # unknown, stays at 1
                                    client_join_request.extend(session_item.user.avatar_equipped)  # currently worn avatar
                                    client_join_request.extend(resize_bytes(session_item.user.guild.encode("ascii"), 8))
                                    client_join_request.extend(int_to_bytes(session_item.user.rank_current, 2))
                                    client_join_request.extend(int_to_bytes(session_item.user.rank_season, 2))

                                client_join_request.extend(self.motd_room.encode("ascii"))
                                client_session.send(0x2111, client_join_request)

                                # notify room host of new join (3010)
                                for session_item in requested_room.player_sessions:
                                    if session_item.is_room_key:
                                        print("Enviando solicitacao de associacao ao host da sala", session_item.user.username)
                                        join_request = bytearray()
                                        join_request.append(client_session.room_slot)
                                        join_request.extend(resize_bytes(client_session.user.username.encode("ascii"), 0xC))
                                        join_request.extend(client_ip)
                                        join_request.extend(client_port)
                                        join_request.extend(client_ip)
                                        join_request.extend(client_port)
                                        join_request.append(client_session.room_tank_primary)  # primary tank
                                        join_request.append(client_session.room_tank_secondary)  # secondary tank
                                        join_request.append(client_session.room_team)  # team side
                                        join_request.extend(client_session.user.avatar_equipped)  # currently worn avatar
                                        join_request.extend(resize_bytes(client_session.user.guild.encode("ascii"), 8))
                                        join_request.extend(int_to_bytes(client_session.user.rank_current, 2))
                                        join_request.extend(int_to_bytes(client_session.user.rank_season, 2))
                                        session_item.send(0x3010, join_request)

                        elif client_command == 0x2010:
                        
                            print("RECEBIDO> SVC_CHANNEL_CHAT")
                            dynamic_payload = client_session.decrypt(data[6:], client_command)
                            chat_message = string_decode(dynamic_payload[1:dynamic_payload[0] + 1])
                            print("Canal Chat de", client_session.user.username, ":", chat_message)

                            padded_username = resize_bytes(client_session.user.username.encode("ascii"), 0xC)
                            chat_broadcast_packet = bytearray()
                            chat_broadcast_packet.append(client_session.channel_position)  # user's channel position
                            chat_broadcast_packet.extend(padded_username)
                            chat_broadcast_packet.append(len(chat_message))
                            chat_broadcast_packet.extend(chat_message.encode("ascii"))

                            # broadcast to all open sockets
                            for session_item in self.world_session:
                                session_item.send_encrypted(0x201F, chat_broadcast_packet)
                                
                            GameServer.solicitando_salas(self, client_session, data);

                        elif client_command == 0x2120:
                            print("RECEBIDO> CRIOU UMA SALA")
                            received_data = data[6:]
                            room_title = string_decode(received_data[1:received_data[0] + 1])
                            # [0:3] game configuration - see 3101, [4:7] pass, [8] room capacity
                            room_other_data = received_data[received_data[0] + 1:]
                            room_playmode = bytes_to_int(room_other_data[2:4], 2)
                            room_playmode_string = "DESCONHECIDO"
                            if room_playmode == 0:
                                room_playmode_string = "SOLO"
                            elif room_playmode == 0x44:
                                room_playmode_string = "SCORE"
                            elif room_playmode == 0x08:
                                room_playmode_string = "TAG"
                            elif room_playmode == 0x0C:
                                room_playmode_string = "JEWEL"
                            room_password = string_decode(room_other_data[4:8])
                            room_capacity = room_other_data[8]
                            created_room = Room(Room.find_room_position(self.world_room), room_title, room_password, 0, room_other_data[0:4], room_capacity)
                            client_session.room_slot = 0  # host room slot
                            client_session.is_room_key = True  # indicates host

                            # reset the client's internal tank values
                            client_session.room_tank_primary = 0xFF
                            client_session.room_tank_secondary = 0xFF

                            created_room.player_sessions.append(client_session)
                            self.world_room.append(created_room)
                            print("Criando sala", room_title, "com senha", room_password, "jogando", room_playmode_string, "para", room_capacity, "jogadores.")

                            room_join_reply = bytearray()
                            room_join_reply.extend(bytes.fromhex("00 00 00"))  # unknown
                            room_join_reply.extend(int_to_bytes(created_room.room_id, 2))
                            room_join_reply.extend(self.motd_room.encode("ascii"))
                            client_session.send(0x2121, room_join_reply)

                        elif client_command == 0x3102:
                            print("RECEBIDO> SVC_ROOM_CHANGE_USEITEM")
                            prop_state_data = data[6:]
                            prop_state = bytes_to_int(prop_state_data[0:2], 2)
                            print("Item de uso da sala alterado:", hex(prop_state), bin(prop_state))
                            self.command_processor.room_update(client_session)

                        elif client_command == 0x3100:
                            print("RECEBIDO> SVC_ROOM_CHANGE_STAGE")
                            new_map_id = data[6]  # map 0 = random
                            selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.map_id = new_map_id
                                print("ID do sala:", selected_room.room_id, "mapa definido como", new_map_id)
                            else:
                                print("A sala selecionada e Nenhum - ignorando")
                            self.command_processor.room_update(client_session)

                        elif client_command == 0x3101:
                            print("RECEBIDO> SVC_ROOM_CHANGE_OPTION")
                            map_properties = data[6:]
                            # game config is stored in a bitwise manner, but the details don't matter on the server
                            selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.game_settings = map_properties
                            self.command_processor.room_update(client_session)

                        elif client_command == 0x3104:
                            print("RECEBIDO> SET_ROOM_TITLE")
                            new_title_raw = data[6:]
                            new_title_string = string_decode(new_title_raw)
                            print("SET_ROOM_TITLE", new_title_string)
                            selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.room_name = new_title_string
                            self.command_processor.room_update(client_session)

                        elif client_command == 0x3103:
                            print("RECEBIDO> SVC_ROOM_CHANGE_MAXMEN")
                            room_capacity = data[6]  # map 0 = random
                            selected_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            if selected_room is not None:
                                selected_room.occupants_max = room_capacity
                                print(selected_room.room_id, "nova capacidade da sala:", room_capacity)
                            self.command_processor.room_update(client_session)

                        elif client_command == 0x3210:
                            print("RECEBIDO> MUDOU DE TIME")
                            new_team_position = data[6]
                            print("Mudando de equipe para", new_team_position)
                            client_session.room_team = new_team_position
                            # probably "RTC" command in IDA
                            client_session.send(0x3211, bytes.fromhex(""), rtc=0)

                        elif client_command == 0x3200:
                            print("RECEBIDO> MUDOU DE MOBILE")
                            mobile_string = {0: "Armor",
                                             1: "Mage",
                                             2: "Nak",
                                             3: "Trico",
                                             4: "Bigfoot",
                                             5: "Boomer",
                                             6: "Raon",
                                             7: "Lightning",
                                             8: "J.D.",
                                             9: "A.Sate",
                                             10: "Ice",
                                             11: "Turtle",
                                             12: "Grub",
                                             13: "Aduka",
                                             17: "Dragon",  # technically 14 (from disassembly), actually 17 (phnx)
                                             18: "Knight",  # technically 15, actually 18 (phnx).
                                             255: "Random"}

                            tank_primary = data[6]
                            tank_secondary = data[7]
                            client_session.room_tank_primary = tank_primary
                            client_session.room_tank_secondary = tank_secondary
                            print(client_session.user.username, "selecionado", tank_primary, tank_secondary)
                            client_session.send(0x3201, bytes.fromhex(""), rtc=0)

                        elif client_command == 0x3230:
                            print("RECEBIDO> SVC_ROOM_USER_READY")
                            ready_state = data[6]
                            print("SVC_ROOM_USER_READY", ready_state)
                            # technically the server should know about this too but we aren't going to check yet
                            client_session.send(0x3231, bytes.fromhex(""), rtc=0)

                        elif client_command == 0x3232:
                            print("RECEBIDO> SVC_ROOM_RETURN_RESULT")
                            client_room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            if client_room is not None:
                                client_room.room_state = 0  # switch room state back to "waiting"
                            client_session.send(0x3233, bytes.fromhex(""), rtc=0)

                        elif client_command == 0x3430:
                            print("RECEBIDO> SVC_START_GAME")
                            if client_session.client_version == 314:  # actually 313, but swapped below when debugging
                                self.command_processor.start_game_anyhowly(data, client_session)
                            elif client_session.client_version == 313 or client_session.client_version == 342:
                                self.command_processor.start_game_gis(data, client_session)
                            else:  # serv2 protocol
                                self.command_processor.start_game_serv2(data, client_session)

                        elif client_command == 0x4200:
                            print("RECEBIDO> SVC_PLAY_END_JEWEL")
                            # probably rebroadcast to all clients (authoritative)
                            message_to_rebroadcast = client_session.decrypt(data[6:], 0x4200)
                            client_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            for session_item in client_room.player_sessions:
                                session_item.send_encrypted(0x4410, message_to_rebroadcast)

                        elif client_command == 0x4100:
                            print("RECEBIDO> SVC_PLAY_USER_DEAD")
                            # input data looks something like 13 00 00 00 00
                            # 4100 is responded with 4102, 4410, 4101
                            # 4102 -> 00130000 00000000 44344700 (broadcast)
                            # 4410 -> FF130000 4BD80DF4 4BD80DF4 (broadcast)
                            client_session.send(0x4101, bytes.fromhex(""))  # reply to origin

                        elif client_command == 0x4412:
                            print("RECEBIDO> SVC_PLAY_RESULT")
                            # host requests 4412, but everyone receives a 4413
                            client_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                            for session_item in client_room.player_sessions:
                                session_item.send(0x4413, bytes.fromhex(""))

                        elif client_command == 0x4500:
                            print("RECEBIDO> SVC_TUNNEL")
                            # first 0xC bytes: metadata? next 0xC bytes: origin, next 0xC bytes: dest
                            # i would have assumed first 0xC bytes were the payload, but sometimes data comes AFTER dest
                            # edit 2: when blocking the client's udp listen port, the client makes a tunnel request
                            # server then forwards the client its own data without the first 2 bytes (wtf?)
                            # normally tunnel activates when something broke somewhere
                            tunnel_bytes = data[6:]
                            # unknown_prefix = tunnel_bytes[0:0xC]
                            requester_id = tunnel_bytes[0xC: 0x18]
                            destination_id = tunnel_bytes[0x18: 0x24]
                            print("Tunel solicitado:", string_decode(requester_id), "para", string_decode(destination_id))

                        elif client_command == 0x6000:
                            print("RECEBIDO> SVC_PROP_GET")
                            flag_send_extended = data[6]
                            user_extended_avatar = client_session.user.avatar_inventory
                            prop_reply = bytearray()
                            prop_reply.extend(client_session.user.avatar_equipped)  # 8 bytes of equipped "short" avatar
                            prop_reply.extend(int_to_bytes(client_session.user.gold, 4))  # user's gold as DWORD
                            if flag_send_extended == 1:
                                prop_reply.extend(int_to_bytes(len(user_extended_avatar), 2))  # avatar count as WORD
                                for avatar_item in user_extended_avatar:
                                    prop_reply.extend(avatar_item)  # add "long" avatar codes (DWORDs)
                            client_session.send_encrypted(0x6001, prop_reply, rtc=0)
                            # send a 1032 cash update too
                            self.command_processor.cash_update(client_session)

                        elif client_command == 0x6004:
                            print("RECEBIDO> SVC_PROP_SET")
                            plain_avatar_equipped = client_session.decrypt(data[6:], 0x6004)
                            avatar_equipped = plain_avatar_equipped[0:8]  # 8 bytes of equipped avatar
                            # should verify if user owns these avatars
                            client_session.user.avatar_equipped = bytes(avatar_equipped)
                            print(client_session.user.username, "equipando", bytes_to_hex(bytes(avatar_equipped)))
                            client_session.send(0x6005, bytes.fromhex(""), rtc=0)
                            User.save_users(self.world_user)

                        elif client_command == 0x6011:
                            print("RECEBIDO> SVC_PROP_BUY_PP")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6011)
                            extended_avatar = plain_bought_avatar[0:4]  # DWORD avatar
                            # normally this is the part where we check the item's price (serverside),
                            # check if player has the cash to purchase, deduct accordingly, send a 1032 update
                            # and store new purchase. for now we're skipping everything
                            print(client_session.user.username, "bought (cash)", bytes_to_hex(bytes(extended_avatar)))
                            client_session.user.avatar_inventory.append(extended_avatar)
                            client_session.send(0x6017, bytes.fromhex(""), rtc=0)
                            self.command_processor.cash_update(client_session)
                            User.save_users(self.world_user)

                        elif client_command == 0x6010:
                            print("RECEBIDO> SVC_PROP_BUY")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6010)
                            extended_avatar = plain_bought_avatar[0:4]  # DWORD avatar
                            # this is 6011 but with gold instead
                            print(client_session.user.username, "comprado (ouro)", bytes_to_hex(bytes(extended_avatar)))
                            client_session.user.avatar_inventory.append(extended_avatar)
                            client_session.send(0x6017, bytes.fromhex(""), rtc=0)
                            User.save_users(self.world_user)

                        elif client_command == 0x6020:
                            print("RECEBIDO> SVC_PROP_SELL")
                            plain_bought_avatar = client_session.decrypt(data[6:], 0x6020)
                            # item_position = plain_bought_avatar[0]  # item position in inventory
                            extended_avatar = plain_bought_avatar[1:5]  # DWORD avatar
                            # we'll acknowledge with OK but not do anything internally
                            print(client_session.user.username, "vendido", bytes_to_hex(bytes(extended_avatar)))
                            client_session.send(0x6027, bytes.fromhex(""), rtc=0)
                            User.save_users(self.world_user)

                        elif client_command == 0x6030:
                            print("RECEBIDO> SVC_PROP_GIFT")
                            gift_plain_packet = client_session.decrypt(data[6:], 0x6030)
                            gift_recipient = string_decode(gift_plain_packet[0:0xC])
                            # unknown_four_bytes = gift_plain_packet[0xC:0x10]
                            # item_position = gift_plain_packet[0x10]  # item position in inventory
                            extended_avatar = gift_plain_packet[0x11:0x15]  # DWORD avatar
                            gift_message = resize_bytes(gift_plain_packet[0x16:], gift_plain_packet[0x15])
                            gift_message = string_decode(gift_message)
                            # we'll acknowledge with OK but not do anything internally
                            print(client_session.user.username, "presenteou", bytes_to_hex(bytes(extended_avatar)), "para",
                                  gift_recipient, "com a mensagem:", gift_message)
                            # 6037 might *not* actually be the OK. I can't remember how gifts worked
                            client_session.send(0x6037, bytes.fromhex(""), rtc=0x6005)
                            User.save_users(self.world_user)

                        elif client_command == 0x5100:
                            print("RECEBIDO> COMANDO GENERICO")
                            
                            
                            command_received_raw = string_decode(data[7:]).split(" ")
                            command_received = command_received_raw.pop(0)
                            command_parameters = " ".join(command_received_raw)

                            print("COMANDO RECEBIDO> " + str(command_received))

                            if command_received == "start" or command_received == "jogar" or command_received == "comecar":

                                print("Jogo iniciado com o comando /" + command_received)

                                if client_session.client_version == 314:  # actually 313, but swapped below when debugging
                                    self.command_processor.start_game_anyhowly(data, client_session)
                                elif client_session.client_version == 313 or client_session.client_version == 342:
                                    self.command_processor.start_game_gis(data, client_session)
                                else:  # serv2 protocol
                                    self.command_processor.start_game_serv2(data, client_session)

                            elif command_received == "mobile":
                                
                                tank_value = int(command_parameters)
                                client_session.room_tank_primary = tank_value
                                response_message = "Seu tanque principal sera definido como " + str(tank_value) + "\nIsso entra em vigor apos entrar em uma sala"
                                self.command_processor.print_to_client(client_session, response_message)

                            elif command_received == "rank":
                            
                                rank_value = int(command_parameters)
                                client_session.user.rank_current = rank_value
                                response_message = "Os numero de rank validos são de -4 a 20\nE necessario fazer login novamente para que as alteracoes entrem em vigor"
                                self.command_processor.print_to_client(client_session, response_message)
                            
                            elif command_received == "guild" or command_received == "cla" or command_received == "clan":
                            
                                client_session.user.guild = command_parameters
                                response_message = "O cla foi alterado para " + command_parameters + "\nE necessario fazer login novamente para que as alteracoes entrem em vigor"
                                self.command_processor.print_to_client(client_session, str(client_session.user.guild))
                            
                            elif command_received == "genero" or command_received == "avatar":
                            
                                if command_parameters == "f":
                                    avatar_random = gerar_avatar_random(command_parameters)
                                else:
                                    avatar_random = gerar_avatar_random("m")

                                client_session.user.avatar_equipped = bytes.fromhex("" + avatar_random[8:12] + "" + avatar_random[0:4] + "" + avatar_random[16:20] + "" + avatar_random[24:28] + "")
                                client_session.user.avatar_inventory = [bytes.fromhex(avatar_random[0:8]),bytes.fromhex(avatar_random[8:16]),bytes.fromhex(avatar_random[16:24]),bytes.fromhex(avatar_random[24:32])]

                                response_message = "E necessario fazer login novamente para que as alteracoes entrem em vigor"
                                self.command_processor.print_to_client(client_session, response_message)


                            elif command_received == "msg" or command_received == "mensagem" or command_received == "aviso":
                                for session_item in self.world_session:
                                    self.command_processor.print_to_client(session_item, command_parameters)

                            elif command_received == "conexao":
                                client_session.send(0x5101, "Conexao ainda ativa".encode("ascii"))

                            elif command_received == "online":
                                for session_item in self.world_session:
                                    if session_item.client is not None:
                                        message_row = session_item.user.username + " : " + session_item.address[0]
                                        self.command_processor.print_to_client(client_session, message_row)

                            elif command_received == "salvar":
                                self.command_processor.print_to_client(client_session, "Salvando - verifique o console python.")
                                
                                User.save_users(self.world_user)
                                self.command_processor.print_to_client(client_session, "Configuracoes salvas")

                            elif command_received == "fechar":
                                client_room: Room = Room.find_room_by_user(self.world_room, client_session.user.username)
                                if client_room is not None:
                                    for room_player in client_room.player_sessions:
                                        room_player.send(0x3FFF, bytes.fromhex(""))
                                        self.command_processor.print_to_client(room_player, "Sala fechada")

                            elif command_received == "sair":
                                client_session.send(0x3FFF, bytes.fromhex(""))
                                self.command_processor.print_to_client(client_session, "Sala fechada")

                            else:
                                self.command_processor.print_to_client(client_session, "O comando nao existe!")

                        else:
                        
                            self.command_processor.print_to_client(client_session, client_command)
                            print("Resposta desconhecida ao comando do cliente:", client_command)
                            
                else:
                    print("GAMESERVER: Cliente desconectado")
                    if client_session is not None:
                        if client_session.channel_position != -1:
                            for session_item in self.world_session:
                                if session_item.user.username != client_session.user.username:
                                    user_channel = bytearray()
                                    user_channel.append(client_session.channel_position)
                                    session_item.send(0x200F, user_channel)
                        if client_session.room_slot != -1:
                            Room.remove_session(self.world_room, client_session.user.username)
                            Room.remove_empty_rooms(self.world_room)
                        Session.remove_session(self.world_session, client_session.user.username)
                    return True
            except Exception as e:
                #client.close()
                self.command_processor.print_to_client(client_session, "Erro no servidor, erro ignorado!")
                print("ERRO: Cliente (GAMESERVER) ignorando erro para continuar online.")
                print(e)
                #return True


# for standalone operation (without coordinator)
if __name__ == "__main__":
    world_session = []
    world_room = []
    world_user = User.get_users(0)
    enabled_server_functions = [FunctionRestrict.EFFECT_THOR, FunctionRestrict.EFFECT_FORCE, FunctionRestrict.EFFECT_MOON, FunctionRestrict.EFFECT_LIGHTNING, FunctionRestrict.AVATAR_ENABLED]

    server: GameServer = GameServer("0.0.0.0", 8370, world_session, world_room, world_user)
    server.gs_funcrestrict = FunctionRestrict.get_function_value(enabled_server_functions)
    threading.Thread(target=server.listen).start()